% PT Abstract Machine Version 5.1
% J.R. Cordy, August 2009 
%    (Revised v5.1 - 8 Feb 2021)
% Copyright 2009, 2021 Queens University at Kingston
%
% This is a new microprogrammed implementation of the PT Abstract Machine,
% as described in J. Alan Rosselet, "PT: A Pascal Subset", Tech Report CSRI-119,
% Computer Systems Research Institute, University of Toronto, Sept 1980.
%
% The PT Abstract Machine is a hypothetical ideal PT computer with a single
% stack architecture.  The PT Abstract Machine has five conceptual units:
%
%    Memory     - simulates the memory unit, with separate code and data spaces
%    ES         - simulates the expression stack
%    ALU        - simulates the arithmetic / logic unit
%    CU         - simulates the control unit
%    TrapHandler - handles all PT traps
%
% The PT machine itself is microprogrammed in S/SL as a set of rules for 
% interaction between these mechanisms, directly interpreting the T-code 
% instructions generated by the semantic phase.
%
% Communication between mechanisms is through a set of shared common registers.
% Important registers are:
%
%    MAR  :     memory address register
%    MDR  :     memory data register
%    IR   :     instruction register
%    PC   :     program counter
%    L,R  :     general purpose registers
%    T    :     trap register
%    SCR  :     source coordination register
%

type BOOLEAN :
        bFALSE  
        bTRUE;

type INSTRUCTION :      % corresponds to semantic.ssl output
        tMultiply 
        firstTcode = tMultiply
        tDivide
        tModulus
        tAdd
        tSubtract
        tEQ
        tNE
        tGT
        tGE
        tLT
        tLE
        tAnd
        tInfixAnd
        tOr
        tInfixOr
        tNegate
        tNot
        tChr
        tOrd
        tEoln
        tEOF
        tVarParm
        tFetchAddress
        tFetchInteger
        tFetchChar
        tFetchBoolean
        tAssignBegin
        tAssignAddress
        tAssignInteger
        tAssignChar
        tAssignBoolean
        tStoreAddress
        tStoreInteger
        tStoreChar
        tStoreBoolean
        tSubscriptBegin
        tSubscriptAddress
        tSubscriptInteger
        tSubscriptChar
        tSubscriptBoolean
        tArrayDescriptor
        tFileDescriptor
        tFileBind
        tIfBegin
        tIfEnd
        tCaseBegin
        tWhileBegin
        tRepeatBegin
        tRepeatControl
        tCallBegin
        tParmEnd
        tProcedureEnd
        tWriteBegin
        tReadBegin
        tTrapBegin
        tWriteEnd
        tReadEnd

        % Compound T-codes are those that take operands
        tLiteralAddress 
        firstCompoundTcode = tLiteralAddress
        tLiteralInteger
        tLiteralChar
        tLiteralBoolean
        tSkipString
        tStringData
        tLiteralString
        tIfThen
        tIfMerge
        tCaseSelect
        tCaseMerge
        tCaseEnd
        tWhileTest
        tWhileEnd
        tRepeatTest
        tSkipProc
        tCallEnd
        tLineNumber
        tTrap
        lastCompoundTcode = tTrap

        tEndOfFile
        lastTcode = tEndOfFile;

type TRAP :
        trHalt = 0
        trReset = 1
        trRewrite = 2
        trRead = 3
        trReadln = 4
        trWrite = 5
        trWriteln = 6
        trWriteString = 7
        trWriteInteger = 8
        trWriteChar = 9
        trReadInteger = 10
        trReadChar = 11
        trAssign = 12
        trSubscriptAbort = 13
        trCaseAbort = 14
        trEoln = 15
        trEof = 16
        trFileBind = 17
        ;

mechanism Memory:
        % The memory mechanism is used to transfer data to or from memory.
        % The memory address register (MAR) points to the target of the fetch or
        % store.  The memory data register (MDR) holds the data to be stored, or,
        % contains the data fetched.
        %
        % MDR := Memory[MAR]     'fetch'
        % Memory[MAR] := MDR     'store'
                                                                        
        oMemoryLoadCode         % Load the code memory from the T-code input file

        oMemoryFetchInstruction % MDR <- Memory[MAR]
                                % Fetch the next instruction from the code memory as
                                % pointed to by the MAR.
                                                                        
        oMemoryFetchOperand     % MDR <- Memory[MAR]
                                % Fetch the operand value from the code memory as
                                % pointed to by the MAR.

        oMemoryFetch            % MDR <- Memory[MAR]
                                % Fetch the operand value from the data memory as 
                                % pointed to by the MAR.
                                                                        
        oMemoryStore            % Memory[MAR] <- MDR
                                % Store the operand value in the MDR to the data memory as 
                                % pointed to by the MAR.
        ;

mechanism ALU:
        % The ALU mechanism is used to manipulate the two general purpose
        % registers L and R, and performs all logical and arithmetic operations.
        % The expression stack, contained within this mechanism, is the vehicle
        % to perform these operations.

        oALUpop                 % <- Stack
                                % Pop and discard the top element of the expression stack.
                                                                        
        oALUpushTrap(TRAP)      % Stack <- trapnumber

        oALUpushL               % Stack <- L
                                % Push the contents of the L register to the expression stack.

        oALUpushR               % Stack <- R
                                % Push the contents of the R register to the expression stack.

        oALUpopL                % L <- Stack
                                % Pop the top element of the expression stack into the L register.
                                                                        
        oALUpopR                % R <- Stack
                                % Pop the top element of the expression stack into the R register.
                                                                        
        oALUchooseR >> BOOLEAN  % R ?
                                % Return FALSE if R is FALSE, return TRUE otherwise.
                                                                        
        oALUpushLplusR          % Stack <- L + R
        oALUpushLminusR         % Stack <- L - R
        oALUpushLtimesR         % Stack <- L * R
        oALUpushLdivR           % Stack <- L div R
        oALUpushLmodR           % Stack <- L mod R
                                % Push the result of the specified integer operation: L op R.
                                                                        
        oALUpushLeqR            % Stack <- L = R
        oALUpushLneR            % Stack <- L <> R
        oALUpushLgtR            % Stack <- L > R
        oALUpushLgeR            % Stack <- L >= R
        oALUpushLltR            % Stack <- L < R
        oALUpushLleR            % Stack <- L <= R
                                % Push the boolean result of the comparison between L and R.
                                                                        
        oALUpushLandR           % Stack <- L and R
        oALUpushLorR            % Stack <- L or R
                                % Push the boolean result of the logical operation on the L and R
                                % registers.
                                                                        
        oALUpushNotR            % Stack <- not R
                                % Push the logical 'not' of the R register.
                                                                        
        oALUpushNegateR         % Stack <- - R
                                % Negate the contents of the R register and push it onto the stack.
                                                                        
        oALUpushChrR            % Stack <- chr(R)
                                % Push the character whose sequence number is stored in the R register.
                                                                        
        oALUpushOrdR            % Stack <- ord(R)
                                % Push the sequence number of the character stored in the R register.
        ;
                                                                        
mechanism CU:
        % This mechanism is used to manipulate the PC, IR, MAR, and MDR. The return
        % stack, used exclusively for procedure/function calls, is also contained
        % within this mechanism.
                                                                        
        oCUchooseInstruction >> INSTRUCTION     
                                % Returns the contents of the IR; the instruction about to be executed.
                                                                        
        oCUzeroPC               % PC <- 0

        oCUmoveMDRtoL           % L <- MDR
        oCUmoveMDRtoR           % R <- MDR
        oCUmoveMDRtoT           % T <- MDR
        oCUmoveMDRtoZ           % Z <- MDR
        oCUmoveMDRtoIR          % IR <- MDR
        oCUmoveMDRtoPC          % PC <- MDR
        oCUmoveMDRtoSCR         % SCR <- MDR
                                % Load the specified register with the contents of the MDR.
                                                                        
        oCUmoveLtoMDR           % MDR <- L
                                % Move the contents of the L register to the MDR.
                                                                        
        oCUmoveRtoMAR           % MAR <- R
        oCUmovePCtoMAR          % MAR <- PC
        oCUmoveMARtoPC          % PC <- MAR
                                % Store the contents of the specified register in the MAR.
                                                                        
        oCUincPC                % PC <- PC + 1
                                % Increment the PC.
                                                                        
        oCUpushPC               % ReturnStack <- PC
                                % Push the PC onto the return stack.
                                                                        
        oCUpopPC                % PC <- ReturnStack
                                % Load the PC with the address on top of the return stack.

        oCUcase                 % PC <- Mem[L+2+R-lower]
                                % Case selector R of case table at address L computation.

        oCUsubscriptCheck       % Subscript R of array at address L range check.
        ;

mechanism TrapHandler:
        % All traps are implemented by the trap mechanism. 

        oTrapHandlerTrap  >> BOOLEAN    
                                % Trap execution to the trap unit.  The contents of the T register
                                % specify the trap number. If true is returned, the trap serviced
                                % was trHalt (therefore, end the program).
        ;


rules
                                                                
PTmachine :
        % The execution cycle of the PT machine:
        %  loop
        %        fetch instruction
        %        decode instruction
        %        exit when instruction = trap trHalt
        %        fetch operands (as required)
        %        execute instruction
        %        store result (as required)
        %  end loop
                                                                
        oMemoryLoadCode                                 % load the code memory from the T-code file
        oCUzeroPC                                       % set PC to 0

        {
                oCUmovePCtoMAR                          % set address of the fetch instruction
                oMemoryFetchInstruction                 % fetch the next instruction..
                oCUmoveMDRtoIR                          % ...and put it into the IR

                [ oCUchooseInstruction                  % CHOOSE on contents of IR

                        | % handle all "no op" instructions
                          tArrayDescriptor, tFileDescriptor, 
                          tAssignBegin, tSubscriptBegin,  tIfBegin,   tIfEnd,  tCaseBegin,  tCaseEnd,          
                          tWhileBegin,  tRepeatBegin,  tRepeatControl, tCallBegin,  tVarParm,  tParmEnd,                
                          tWriteBegin, tReadBegin, tWriteEnd, tReadEnd, tTrapBegin, tInfixAnd,  tInfixOr:
                                oCUincPC

                        | tAssignAddress:               %  address assignment
                                oALUpopL                % L <- pop
                                oALUpopR                % R <- pop
                                oCUmoveRtoMAR
                                oCUmoveLtoMDR
                                oMemoryStore            % Mem[R] <- L
                                oCUincPC
                        | tAssignInteger:               % integer assignment
                                oALUpopL                % L <- pop
                                oALUpopR                % R <- pop
                                oCUmoveRtoMAR
                                oCUmoveLtoMDR
                                oMemoryStore
                                oCUincPC
                        | tAssignChar:                  % char assignment
                                oALUpopL                % L <- pop
                                oALUpopR                % R <- pop
                                oCUmoveRtoMAR
                                oCUmoveLtoMDR
                                oMemoryStore
                                oCUincPC
                        | tAssignBoolean:               % boolean assignment
                                oALUpopL                % L <- pop
                                oALUpopR                % R <- pop
                                oCUmoveRtoMAR
                                oCUmoveLtoMDR
                                oMemoryStore
                                oCUincPC
                        | tStoreAddress:                % reverse address assignment
                                oALUpopR                % R <- pop
                                oALUpopL                % L <- pop
                                oCUmoveRtoMAR
                                oCUmoveLtoMDR
                                oMemoryStore            % Mem[R] <- L
                                oCUincPC
                        | tStoreInteger:                % reverse integer assignment
                                oALUpopR                % R <- pop
                                oALUpopL                % L <- pop
                                oCUmoveRtoMAR
                                oCUmoveLtoMDR
                                oMemoryStore
                                oCUincPC
                        | tStoreChar:                   % reverse char assignment
                                oALUpopR                % R <- pop
                                oALUpopL                % L <- pop
                                oCUmoveRtoMAR
                                oCUmoveLtoMDR
                                oMemoryStore
                                oCUincPC
                        | tStoreBoolean:                % reverse boolean assignment
                                oALUpopR                % R <- pop
                                oALUpopL                % L <- pop
                                oCUmoveRtoMAR
                                oCUmoveLtoMDR
                                oMemoryStore
                                oCUincPC
                        | tFetchAddress :               % fetch an address from memory:
                                oALUpopR                % R <- pop
                                oCUmoveRtoMAR
                                oMemoryFetch            % MDR <- Mem[R]
                                oCUmoveMDRtoR           % R <- MDR
                                oALUpushR               % push (R)
                                oCUincPC
                        | tFetchInteger  :              % fetch integer
                                oALUpopR
                                oCUmoveRtoMAR
                                oMemoryFetch
                                oCUmoveMDRtoR
                                oALUpushR
                                oCUincPC
                        | tFetchChar :                  % fetch char
                                oALUpopR
                                oCUmoveRtoMAR
                                oMemoryFetch
                                oCUmoveMDRtoR
                                oALUpushR
                                oCUincPC
                        | tFetchBoolean :               % fetch boolean
                                oALUpopR
                                oCUmoveRtoMAR
                                oMemoryFetch
                                oCUmoveMDRtoR
                                oALUpushR
                                oCUincPC
                        | tLiteralAddress :             % push literal address operand
                                oCUincPC                % prepare to fetch operand
                                oCUmovePCtoMAR
                                oMemoryFetchOperand     % get it
                                oCUmoveMDRtoR
                                oALUpushR               % push it onto the expn stack
                                oCUincPC
                        | tLiteralInteger :             % push literal integer
                                oCUincPC
                                oCUmovePCtoMAR
                                oMemoryFetchOperand 
                                oCUmoveMDRtoR
                                oALUpushR
                                oCUincPC
                        | tLiteralChar :                % push literal char
                                oCUincPC
                                oCUmovePCtoMAR
                                oMemoryFetchOperand
                                oCUmoveMDRtoR
                                oALUpushR
                                oCUincPC
                        | tLiteralBoolean :             % push literal boolean
                                oCUincPC
                                oCUmovePCtoMAR
                                oMemoryFetchOperand
                                oCUmoveMDRtoR
                                oALUpushR
                                oCUincPC
                        | tLiteralString :              % push literal string's code address
                                oCUincPC                % prepare to fetch operand
                                oCUmovePCtoMAR
                                oMemoryFetchOperand     % get it
                                oCUmoveMDRtoR
                                oALUpushR               % push it onto the expn stack
                                oCUincPC

                        | tSubscriptAddress, tSubscriptInteger, tSubscriptChar, tSubscriptBoolean :
                                % perform subscripting calculation
                                oALUpopR                % subscript value
                                oALUpopL                % address of array
				oCUsubscriptCheck	% check subscript in range
                                oALUpushLplusR          % all data types unit size
                                oCUincPC
                        | tIfThen :                     % perform conditional if test
                                oALUpopR                % value of if expression
                                oCUincPC
                                [ oALUchooseR                           % if not R then
                                        | bFALSE:
                                                oCUmovePCtoMAR          % fetch address and
                                                oMemoryFetchOperand
                                                oCUmoveMDRtoPC          % assign it to the PC
                                        | *:                            % else
                                                oCUincPC                % skip address
                                ]
                        | tIfMerge, tCaseMerge, tWhileEnd, tSkipProc, tSkipString:
                                % simple jumps
                                oCUincPC
                                oCUmovePCtoMAR          % fetch address and
                                oMemoryFetchOperand
                                oCUmoveMDRtoPC          % assign it to the PC
                        | tWhileTest, tRepeatTest:      % perform conditional if test
                                oALUpopR                % value of exit expression
                                oCUincPC
                                [ oALUchooseR                           % if R then
                                        | bTRUE:
                                                oCUincPC                % skip address
                                        | *:                            % else
                                                oCUmovePCtoMAR          % fetch address and
                                                oMemoryFetchOperand
                                                oCUmoveMDRtoPC          % assign it to the PC
                                ]
                        | tCaseSelect :                 % perform case selection
                                oALUpopR                % R <- pop
                                oCUincPC                
                                oCUmovePCtoMAR          % fetch table address operand
                                oMemoryFetchOperand
                                oCUmoveMDRtoL           % L <- table address
                                oCUcase                 % PC <- Mem[L+2+R-lower]
                        | tCallEnd :                    % procedure call
                                oCUincPC                
                                oCUmovePCtoMAR          % fetch procedure address
                                oMemoryFetchOperand
                                oCUincPC                % increment PC and...
                                oCUpushPC               % push return address
                                oCUmoveMDRtoPC          % PC <- procedure address
                        | tProcedureEnd :               % procedure return
                                oCUpopPC                % pop return address
                        | tLineNumber :                 % set source coordination reg
                                oCUincPC                
                                oCUmovePCtoMAR          % fetch integer operand
                                oMemoryFetchOperand
                                oCUmoveMDRtoSCR         % SCR <- integer operand
                                oCUincPC
                        | tTrap :                       % invoke trap handler
                                oCUincPC
                                oCUmovePCtoMAR          % fetch trap number
                                oMemoryFetchOperand
                                oCUmoveMDRtoT           % T <- trap number
                                [ oTrapHandlerTrap      % perform trap
                                     | bTRUE:           % halt trap
                                        >
                                     | *:
                                ]
                                oCUincPC

                        % Unary operators:
                        | tNegate :                     % integer negation of R
                                oALUpopR
                                oALUpushNegateR
                                oCUincPC
                        | tNot :                        % logical NOT 
                                oALUpopR                
                                oALUpushNotR
                                oCUincPC
                        | tChr :                        % perform CHR 
                                oALUpopR
                                oALUpushChrR
                                oCUincPC
                        | tOrd :                        % perform ORD
                                oALUpopR
                                oALUpushOrdR
                                oCUincPC

                        % Pseudo-instruction traps:
                        | tEoln :
                                oALUpushTrap(trEoln)
                                oALUpopL
                                oCUmoveLtoMDR
                                oCUmoveMDRtoT           % T <- trEoln
                                [ oTrapHandlerTrap      % pushes result
                                     | bFALSE:          % not halt trap         
                                ]
                                oCUincPC
                        | tEOF :
                                oALUpushTrap(trEof)
                                oALUpopL
                                oCUmoveLtoMDR
                                oCUmoveMDRtoT           % T <- trEof
                                [ oTrapHandlerTrap      % pushes result
                                     | bFALSE:          % not halt trap         
                                ]
                                oCUincPC
                        | tFileBind:
                                oALUpushTrap(trFileBind)
                                oALUpopL
                                oCUmoveLtoMDR
                                oCUmoveMDRtoT           % T <- trFileBind
                                [ oTrapHandlerTrap      % pushes result
                                     | bFALSE:          % not halt trap         
                                ]
                                oCUincPC

                        % Binary operators:
                        | tMultiply:
                                oALUpopR            
                                oALUpopL
                                oALUpushLtimesR
                                oCUincPC
                        | tDivide:
                                oALUpopR            
                                oALUpopL
                                oALUpushLdivR
                                oCUincPC
                        | tModulus:
                                oALUpopR            
                                oALUpopL
                                oALUpushLmodR
                                oCUincPC
                        | tAdd:
                                oALUpopR            
                                oALUpopL
                                oALUpushLplusR
                                oCUincPC
                        | tSubtract:
                                oALUpopR            
                                oALUpopL
                                oALUpushLminusR
                                oCUincPC
                        | tAnd:
                                oALUpopR            
                                oALUpopL
                                oALUpushLandR
                                oCUincPC
                        | tOr:
                                oALUpopR            
                                oALUpopL
                                oALUpushLorR
                                oCUincPC
                        | tEQ:                          % L = R
                                oALUpopR            
                                oALUpopL
                                oALUpushLeqR
                                oCUincPC
                        | tNE:                          % L <> R
                                oALUpopR            
                                oALUpopL
                                oALUpushLneR
                                oCUincPC
                        | tGT:                          % L > R
                                oALUpopR
                                oALUpopL
                                oALUpushLgtR
                                oCUincPC
                        | tGE:                          % L > R
                                oALUpopR
                                oALUpopL
                                oALUpushLgeR
                                oCUincPC
                        | tLT:                          % L < R
                                oALUpopR
                                oALUpopL
                                oALUpushLltR
                                oCUincPC
                        | tLE:                          % L < R
                                oALUpopR
                                oALUpopL
                                oALUpushLleR
                                oCUincPC
                ]
        };
end
