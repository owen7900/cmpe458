{  PT scanner-parser pass  Ver. 5.1

   Date:  30 Jun 1980
          (Revised v5.1 - 8 Feb 2021)

   Author:  Alan Rosselet      

   Abstract:
     The scanner-parser pass of the PT compiler consists of two modules, 
     a scanner-screener and a parser, which interact as coroutines.

     Both modules are table driven by separately specified S/SL programs.  
     The routines of this program implement the primitive operations and 
     semantic operations invoked by those S/SL programs.

  Input Files:
       stdIdentifiers:     PT keywords and predeclared identifiers
       scanSsl, parseSsl:  S/SL tables to drive the scanner and parser
       source:             User program text
       options:  Scanner/Parser compiler options. Recognized options are:
            o1 - run as scanner only
            t1 - trace scanner execution
            t2 - trace parser execution
            l - suppress generation of run-time source coordinate information
            DD - (D is a decimal digit) the first DD characters
                 of identifiers in the user program are 
                 significant (DD >= 09 and DD <= 31).

   Output Files:
       parseStream:  Parsed token stream (in postfix) 
                         for input to the semantic analysis pass.
       output:       Diagnostic messages.
}


program ScannerParser(output, stdIdentifiers, scanSsl, parseSsl, source, parseStream, options);

    const
        { S/SL Table Walker Operations }
        { Primitive S/SL Table Operations }
        oCall = 0;
        oReturn = 1;
        oRuleEnd = 2;
        oJumpBack = 3;
        oJumpForward = 4;
        oInput = 5;
        oInputAny = 6;
        oInputChoice = 7;
        oEmit = 8;
        oError = 9;
        oChoice = 10;
        oChoiceEnd = 11;
        oSetParameter = 12;
        oSetResult = 13;

{ ===== Pasted contents of scan.def, generated by S/SL from scan.ssl -
        defines Scanner Semantic Operations, Input/Output Tokens, Error Codes and Semantic Types }

        { Semantic Operations }
        oBufferSave = 14;

        { Input Tokens }
        lLetter = 0;
        firstCharClass = 0;
        lDigit = 1;
        lPlus = 2;
        lMinus = 3;
        lStar = 4;
        lColon = 5;
        lEquals = 6;
        lDot = 7;
        lComma = 8;
        lSemicolon = 9;
        lQuote = 10;
        lBackslash = 11;
        lLeftAngle = 12;
        lRightAngle = 13;
        lLeftParen = 14;
        lRightParen = 15;
        lLeftBracket = 16;
        lRightBracket = 17;
        lLeftBrace = 18;
        lRightBrace = 19;
        lBlank = 20;
        lIllegal = 21;
        lNewLine = 22;
        lCarriageReturn = 23;
        lTab = 24;
        lNewPage = 25;
        lEndFile = 26;
        lastCharClass = 26;

        { Output Tokens }
        pDiv = 0;
        firstKeywordToken = 0;
        pMod = 1;
        pOr = 2;
        pAnd = 3;
        pNot = 4;
        pThen = 5;
        pElse = 6;
        pOf = 7;
        pEnd = 8;
        pUntil = 9;
        pDo = 10;
        pArray = 11;
        pFile = 12;
        pProgram = 13;
        pConst = 14;
        pVar = 15;
        pType = 16;
        pProcedure = 17;
        pBegin = 18;
        pIf = 19;
        pCase = 20;
        pWhile = 21;
        pRepeat = 22;
        lastKeywordToken = 22;
        pIdentifier = 23;
        firstCompoundInputToken = 23;
        pInteger = 24;
        pStringLiteral = 25;
        lastCompoundInputToken = 25;
        pNewLine = 26;
        pEndFile = 27;
        pPlus = 28;
        pMinus = 29;
        pStar = 30;
        pColonEquals = 31;
        pDot = 32;
        pComma = 33;
        pSemicolon = 34;
        pColon = 35;
        pEquals = 36;
        pNotEqual = 37;
        pLess = 38;
        pLessEqual = 39;
        pGreaterEqual = 40;
        pGreater = 41;
        pLeftParen = 42;
        pRightParen = 43;
        pLeftBracket = 44;
        pRightBracket = 45;
        pDotDot = 46;
        lastSyntaxToken = 46;

        { Input/Output Tokens }

        { Error Codes }
        eIllegalChar = 5;
        firstScanError = 5;
        eStringLiteralLine = 6;
        eStringLiteralEOF = 7;
        eCommentEOF = 8;
        eNoSeparator = 9;
        lastScanError = 9;

        { Type Values }

        { S/SL Rule Table Addresses } {
        Scan = 0;
        Identifier = 212;
        AlternateComment = 325;
        Integer = 229;
        StringLiteral = 244;
        Comment = 296;
        }

        { S/SL Table Parameters }
        sslTblSize = 361;
        minSslTableValue = -32767;
        maxSslTableValue = 32767;

{ ===== End of contents of scan.def }


{ ===== Pasted contents of parser.def, generated by S/SL from parser.ssl -
        defines Parser Semantic Operations, Input/Output Tokens, Error Codes and Semantic Types }

        { Semantic Operations }

        { Input Tokens } {
        pDiv = 0;
        firstKeywordToken = 0;
        pMod = 1;
        pOr = 2;
        pAnd = 3;
        pNot = 4;
        pThen = 5;
        pElse = 6;
        pOf = 7;
        pEnd = 8;
        pUntil = 9;
        pDo = 10;
        pArray = 11;
        pFile = 12;
        pProgram = 13;
        pConst = 14;
        pVar = 15;
        pType = 16;
        pProcedure = 17;
        pBegin = 18;
        pIf = 19;
        pCase = 20;
        pWhile = 21;
        pRepeat = 22;
        lastKeywordToken = 22;
        pIdentifier = 23;
        firstCompoundInputToken = 23;
        pInteger = 24;
        pStringLiteral = 25;
        lastCompoundInputToken = 25;
        pNewLine = 26;
        pEndFile = 27;
        pPlus = 28;
        pMinus = 29;
        pStar = 30;
        pColonEquals = 31;
        pDot = 32;
        pComma = 33;
        pSemicolon = 34;
        pColon = 35;
        pEquals = 36;
        pNotEqual = 37;
        pLess = 38;
        pLessEqual = 39;
        pGreaterEqual = 40;
        pGreater = 41;
        pLeftParen = 42;
        pRightParen = 43;
        pLeftBracket = 44;
        pRightBracket = 45;
        pDotDot = 46;
        lastSyntaxToken = 46;
        }

        { Output Tokens }
        sIdentifier = 0;
        firstSemanticToken = 0;
        firstCompoundSemanticToken = 0;
        sInteger = 1;
        sStringLiteral = 2;
        lastCompoundSemanticToken = 2;
        sProgram = 3;
        sParmBegin = 4;
        sParmEnd = 5;
        sConst = 6;
        sType = 7;
        sVar = 8;
        sProcedure = 9;
        sBegin = 10;
        sEnd = 11;
        sNegate = 12;
        sArray = 13;
        sFile = 14;
        sRange = 15;
        sCaseStmt = 16;
        sCaseEnd = 17;
        sLabelEnd = 18;
        sExpnEnd = 19;
        sNullStmt = 20;
        sAssignmentStmt = 21;
        sSubscript = 22;
        sCallStmt = 23;
        sFieldWidth = 24;
        sIfStmt = 25;
        sThen = 26;
        sElse = 27;
        sWhileStmt = 28;
        sRepeatStmt = 29;
        sRepeatEnd = 30;
        sEq = 31;
        sNE = 32;
        sLT = 33;
        sLE = 34;
        sGT = 35;
        sGE = 36;
        sAdd = 37;
        sSubtract = 38;
        sMultiply = 39;
        sDivide = 40;
        sModulus = 41;
        sInfixOr = 42;
        sOr = 43;
        sInfixAnd = 44;
        sAnd = 45;
        sNot = 46;
        sNewLine = 47;
        sEndOfFile = 48;
        lastSemanticToken = 48;

        { Input/Output Tokens }

        { Error Codes }

        { Type Values }

        { S/SL Rule Table Addresses } {
        Program = 0;
        Block = 34;
        ConstantDefinitions = 86;
        TypeDefinitions = 176;
        VariableDeclarations = 287;
        ProcedureHeading = 317;
        BeginStmt = 491;
        ConstantValue = 116;
        UnsignedIntegerConstant = 156;
        TypeBody = 206;
        SimpleType = 238;
        OptionallySignedIntegerConstant = 267;
        Statement = 365;
        AssignmentOrCallStmt = 407;
        IfStmt = 517;
        WhileStmt = 604;
        CaseStmt = 541;
        RepeatStmt = 615;
        Expression = 645;
        CallStmt = 447;
        CaseAlternative = 584;
        SimpleExpression = 699;
        Term = 752;
        Factor = 796;
        IdentifierExtension = 854;
        }

        { S/SL Table Parameters } {
        sslTblSize = 884;
        minSslTableValue = -32767;
        maxSslTableValue = 32767;
        }

{ ===== End of contents of parser.def }


        { Nonexistent parser input token used only in syntax error recovery }
        firstSyntaxToken  =  -1;
        pSyntaxError = -1;

        { Error codes }
        firstErrorCode = 0;
        eTextBufferOverflow = 0;
        eIdentTextOverflow = 1;
        eIdentTableOverflow = 2;
        eParseCallStackOvfl = 3;
        ePrematureEOF = 4;
        lastAbortCode = 4;

        { Scanner error codes are defined in scan.def above }

        { Screener error codes - values must be bigger than scanner error codes }
        eNullString = 20;
        eIntegerOverflow = 21;
        eIdentifierTooLong = 22;
        eSyntaxError = 23;
        eOptionsError = 24;
        eExtraneousSource = 25;
        lastErrorCode = 25;

        { S/SL failure codes }
        firstFailureCode = 0;
        fSemanticChoiceFailed = 0;
        fChoiceRuleFailed = 1;
        lastFailureCode = 1;

        { Each assertion in the program is tagged with a unique identifying value - 
          this makes it easy to find assertion failure conditions by searching for 
          'assertNN' below when assertion NN fails. }
        assert1 = 1;
        assert2 = 2;
        assert3 = 3;
        assert4 = 4;
        assert5 = 5;
        assert6 = 6;
        assert7 = 7;
        assert8 = 8;
        assert9 = 9;
        assert10 = 10;
        assert11 = 11;
        assert12 = 12;
        assert13 = 13;
        assert14 = 14;
        assert15 = 15;
        assert16 = 16;
        assert17 = 17;

        { Translator limits }
        scanTableSize = 1000;        { max }
        parseTableSize = 3000;       { max }
        maxStdIdentifiers = 50;
        textBufferSize = 200;
        identTableSize = 1601;       { must be prime }
        identTextSize = 16000;
        charSetSize = 127;           { actually size-1 }
        maxInteger = 32767;
        maxIntDivTen = 3276;
        maxIntModTen = 7;
        shiftLeft7 = 128;
        shiftLeft4 = 16;
        minInteger = -32767;
        maxIdentifierLength = 100;
        minSignificantChars = 8;     { in an identifier }
        maxLineNumber = 9999;
        maxErrors = 100;
        scanCallStackSize = 5;

        { dummy identifier-token value used in syntax error recovery }
        defaultIdentifier = -1;

        { misc. }
        tab = '	';
        blank = ' ';
        quote = '''';
        null = 0;

        { Phase identification values - for use by common routines }
        scan = 0;
        parse = 1;

    type
        IdentTextReference = 0 .. identTextSize;
        CharClass = firstCharClass .. lastCharClass;
        SyntaxToken = firstSyntaxToken .. lastSyntaxToken;
        FailureCodes = firstFailureCode .. lastFailureCode;
        ErrorCodes = firstErrorCode .. lastErrorCode;
        IdentTableReference = 1 .. identTableSize;
        PhaseNames =  scan .. parse;

    var
        { Scanner-Screener variables }

        { scanner input stream - PT source program }
        source: text;

        { keywords and predeclared identifiers }
        stdIdentifiers: text;

        { scanner S/SL }
        scanSsl: file of integer;

        { S/SL table to drive the scanner }
        scanTable: array [0 .. scanTableSize] of integer;

        { The S/SL Rule Call Stack:
          The Rule Call Stack implements Syntax/Semantic Language rule call and return.
          Each time an oCall operation is executed, the table return address is pushed onto the
          Rule Call Stack.  When an oReturn is executed, the return address is popped from 
          the stack.  An oReturn executed when the Rule Call Stack is empty terminates 
          table execution.  The scanner call stack and table pointer are global so the
          scanner can operate as a coroutine with the parser. }
        scanCallStackTop: 0 .. scanCallStackSize;
        scanCallStack: array [1 .. scanCallStackSize] of 0 .. scanTableSize;
        scanTablePointer: 0 .. scanTableSize;

        { Scanner table walker termination control. Initially true;
          set false at normal end of processing and upon encountering an unrecoverable error. }
        scanning: Boolean;

        { Buffer which temporarily stores the text for compound tokens identifier, 
          integer and literal after their acceptance.  The text of literal string tokens 
          is passed from the scanner to the parser via this variable. }
        textBuffer: array [1 .. textBufferSize] of char;
        tokenTextLength: 0 .. textBufferSize;

        { Significant identifier characters; default is maxIdentifierLength }
        significantChars: 0 .. maxIdentifierLength;

        inputChar: char;        { last char read from source }
        lastInputChar: char;    { char read prior to inputChar }
        scanToken: CharClass;   { char class corresponding to inputChar }

        { Text table : storage for the character representation of identifiers }
        identText: array [1 .. identTextSize] of char;
        identTextEnd: IdentTextReference;  { last allocated text table slot }

        { Lookup table which is used to determine a character's lexical
          token class based on its ordinal value in the collating sequence }
        charClassMap: array [0 .. charSetSize] of CharClass;

        { Identifier table :  3 fields, text index, length and value }
        { Pointer to the character representation of the ident }
        identTextIndex: array [IdentTableReference] of IdentTextReference;
        { Number of characters in the ident }
        identLength: array [IdentTableReference] of char;        { chr(length) }
        { The value used to distinguish identifier tokens is the current number of identifiers 
          (standard and user defined) that have been entered in the ident table. Keywords have
          negative values in this field. }
        identTokenValue: array [IdentTableReference] of integer;
        { Number of occupied ident table entries }
        numberOfIdents: 0 .. identTableSize;
        { Number of initialized standard ident table entries }
        numberStdIdentifiers: 0 .. maxStdIdentifiers;

        { An ident table index which is computed as a function of the character representation 
          of an identifer. }
        hashValue: IdentTableReference;


        { Parser variables }

        { Parser S/SL }
        parseSsl: file of integer;

        { S/SL table to drive the parser }
        parseTable: array [0 .. parseTableSize] of integer;
        parseTablePointer: 0 .. parseTableSize;

        { Operation being executed by the Parser S/SL table walker }
        parserOperation: integer;

        { Parser table walker termination control. Initially true; set false at normal end 
          of processing and upon encountering an unrecoverable error. }
        parsing: Boolean;

        { Communication channel between the Scanner and Parser.  
          Compound tokens have associated values :  identifier - ident table index,
          integer - value.  The text and length of identifiers and literals is passed 
          via textBuffer and tokenTextLength. }
        parseInputToken: SyntaxToken;
        parseTokenValue: integer;

        { Parser's private copy of compound token components.  
          These values are accessed by the semantic operations of the parser. }
        compoundToken: SyntaxToken;        { identifier, integer or literal }
        compoundTokenValue: integer;
        compoundTokenLength: 0 .. textBufferSize;
        compoundTokenText: array [1 .. textBufferSize] of char;

        { Parser output token stream }
        parseStream: file of integer;

        { Options Control }
        options: text;
        scanonly: Boolean;      { default is false }
        scantracing: Boolean;   { default is false }
        parsetracing: Boolean;  { default is false }
        { Number of characters to be used to distinguish user-defined identifiers;  
          the default value is maxIdentifierLength. }
        significantIdentTextSize: minSignificantChars .. maxIdentifierLength;

        { Flag set when translation is being aborted }
        abort: Boolean;         { initially false }

        { Variables Used in Syntax Error Recovery }
        newInputLine: Boolean;  { initially false }
        savedInputToken: SyntaxToken;
        { Syntax error line number }
        lineNumber: 0 .. maxLineNumber;
        { Scanner error lookahead line number }
        nextLineNumber: 0 .. maxLineNumber;
        { Number of errors detected so far }
        errorCount: integer;

        { misc. }
        backslash: char;
        newline: char;
        carriagereturn: char;

        { UNIX argument file identifiers, for gpc compatibility }
        {== 
        NstdIdentifiers, NscanSsl, NparseSsl, Nsource, NparseStream, Noptions:
            array [1 .. 50 ] of char; 
        ==}


    procedure Assert (assertion: Boolean; number: integer);
        { Procedure to implement programmer assertion checking with identification numbers. }
        begin
            if not assertion then
                begin
                    write ('### Scanner/Parser assertion ', number: 1, ' failed: ');
                    case number of
                        assert1:
                            ; { Problem message already reported }
                        assert2:
                            write ('scanTableSize too small (increase in parser.pt)');
                        assert3:
                            write ('parseTableSize too small (increase in parser.pt)');
                        assert4, assert5, assert6, assert7, assert8, assert9, assert10, assert11, 
                        assert12, assert13, assert14, assert15, assert16, assert17:
                            write ('internal error in parser.pt (report to maintainer)');
                    end;
                    writeln;
                    scanning := false;
                    parsing := false;
                    abort := true
                end;
        end { Assert };


    procedure SslFailure (failCode: FailureCodes);
        begin
            write ('### Scanner/Parser S/SL program failure:  ');

            case failCode of
                fSemanticChoiceFailed:
                    write ('Semantic choice failed');
                fChoiceRuleFailed:
                    write ('Choice rule returned without a value');
            end;

            writeln;
            write ('while processing line ', lineNumber);
            writeln;
            Assert (false, assert1);
        end { SslFailure };


    procedure ReportSyntaxError;
        { Print the token at which the syntax error was detected.
          Error has already printed the label for the error message. }
        var
            i:integer;
        begin
            if parseInputToken > lastCompoundInputToken then
                { The token is a Pascal special symbol }
                write (lastInputChar)
            else
                { Identifier, integer or literal }
                begin
                    i := 1;
                    while i <= tokenTextLength do
                        begin
                            write (textBuffer[i]);
                            i := i+1;
                        end
                end;

        end { ReportSyntaxError };


    procedure Error(errorCode:  ErrorCodes);
        { Report errors and abort translation if the error was fatal }
        begin
            write('scan/parse error, line ', nextLineNumber: 1, ': ');

            case errorCode of
                eExtraneousSource:
                    write('extraneous program text - ignored');
                eIdentifierTooLong:
                    write('warning, identifier truncated');
                eIllegalChar:
                    write('illegal character - deleted');
                eIntegerOverflow:
                    write('integer too large - truncated');
                eIdentTableOverflow:
                    write('too many identifiers (ident table)');
                eIdentTextOverflow:
                    write('too many identifiers (ident text)');
                eNullString:
                    write('null literal string');
                eOptionsError:
                    write('error in specifying compiler option');
                eParseCallStackOvfl:
                    write('nesting too deep (parse call stack)');
                eTextBufferOverflow:
                    write('identifier or string too long');
                eSyntaxError:
                    begin
                        write('syntax error at: ');
                        ReportSyntaxError
                    end;
                eCommentEOF:
                    write('unclosed comment');
                eStringLiteralEOF:
                    write('unclosed literal string');
                eStringLiteralLine:
                    write('literal string crosses line boundary');
                eNoSeparator:
                    write('separator required between integers and identifiers');
                ePrematureEOF:
                    write('unexpected end of file');
            end { case errorCode };

            writeln;

            errorCount := errorCount + 1;

            if (errorCount > maxErrors) or
               (errorCode <= lastAbortCode) then
                begin
                    write('translation aborted');
                    writeln;
                    parsing := false;
                    abort := true;
                end;

        end { Error };


    procedure IdentCompare(identReference:IdentTableReference;
                          var found: Boolean);
        { Compare the identifier just read to an entry in identText,
          setting found to true if they match, false otherwise. }
        var
            i: 1 .. textBufferSize;
            j: IdentTextReference;
            charsToCompare: 1 .. maxIdentifierLength;

        begin
            if identTokenValue[identReference] <= 0 then
                { We are comparing to a keyword, so the entire identifier is significant 
                  in the comparison }
                charsToCompare := tokenTextLength
            else
                { Compare only the specified number of characters for non-keyword entries. }
                charsToCompare := significantChars;

            found := identLength[identReference] = chr(charsToCompare);

            if found then        { lengths match, now compare text }
                begin
                    i := 1;
                    j := identTextIndex[identReference];
                    repeat
                        found := identText[j] = textBuffer[i];
                        j := j + 1;
                        i := i + 1
                    until not found or (i > charsToCompare);
                end

        end { IdentCompare };


    procedure IdentEnter(identReference: IdentTableReference);
        { Enter the character representation of the last identifier accepted
          into the text table and set the text table pointer and ident length
          fields of the argument ident table entry. }
        var 
            i: integer;
            charsToEnter: 1 .. maxIdentifierLength;

        begin
            numberOfIdents := numberOfIdents + 1;
            identTextIndex[identReference] := identTextEnd + 1;
            { The value used to distinguish identifier tokens is the current number of 
              identifiers (standard and user defined) that have been entered in the ident table. 
              Keywords are distinguished from other identifiers by their negative values. }
            identTokenValue[identReference] := 
                        numberOfIdents - lastKeywordToken - 1;

            if identTokenValue[identReference] <= 0 then
                { A keyword is being entered; enter its full ident regardless of the number 
                  of significant characters requested by the user through the options file. }
                charsToEnter := tokenTextLength
            else
                { Enter only as many characters as were requested in options for 
                  user-defined identifiers.         }
                charsToEnter := significantChars;

            i := 1;
            repeat
                identTextEnd := identTextEnd + 1;
                identText[identTextEnd] := textBuffer[i];
                i := i + 1
            until i > charsToEnter;

            identLength[identReference] := chr(charsToEnter);

        end { IdentEnter };


    procedure IdentLookup;
        { Lookup the last accepted ident in the ident table using a hash function.  
          If the ident is not in the table enter it.             }
        const
            firstCharBitShift = 128;
            lastCharBitShift = 16;
        var
            found: Boolean;

        begin
            { Hashing of all identifiers, user-defined and keywords, must use only the number 
              of significant characters specified in options.  IdentCompare handles the case
              of keywords which happen to exceed the significance limit.}
            hashValue := ((ord(textBuffer[1]) * firstCharBitShift)
                      + (ord(textBuffer[significantChars]) * lastCharBitShift)
                      + significantChars) mod identTableSize + 1;
            repeat
                if identTextIndex[hashValue] = null then        { a new ident }
                    if (identTextSize - identTextEnd < tokenTextLength) then
                        Error(eIdentTextOverflow)
                    else
                        begin
                            IdentEnter(hashValue);
                            found := true;
                        end
                else if (numberOfIdents >= identTableSize) then
                    Error(eIdentTableOverflow)
                else
                    begin
                        IdentCompare(hashValue, found);
                        if not found then
                            { The secondary hash must also use the number of significant 
                              characters in the identifier. }
                            hashValue := (hashValue + significantChars)
                                    mod identTableSize + 1
                    end;
            until found;

        end { IdentLookup };


    procedure AcceptScanToken;
        { Read the next character from the source program text (if any remain) 
          and determine the lexical token class to which it belongs. }
        var acceptedScanToken:CharClass;
        begin
            acceptedScanToken := scanToken;
            lastInputChar := inputChar;
            { Get a character from the input stream, placing its character
              representation in inputChar and its class value in scanToken.}
            if eof(source) then
                scanToken := lEndFile
            else if eoln(source) then
                begin
                    readln(source);
                    scanToken := lNewLine
                end
            else
                begin
                    read(source, inputChar);
                    scanToken := charClassMap[ord(inputChar)];
                end;

            if scantracing then
                begin
                    write ('Input token accepted ', acceptedScanToken: 1,
                        ';  Line ', lineNumber: 1, ';  Next scan token ', scanToken: 1);
                    if (scanToken <> lEndFile) and (scanToken <> lNewLine) then
                        write (' "', inputChar, '"');
                    writeln
                end

        end { AcceptScanToken };


    procedure Initialize;
        { Set up the charClassMap, initialize the scanner and parser S/SL tables, 
          insert keywords and predeclared identifiers in the ident table 
          and set any requested options. }
        var
            i: integer;
            c: char;

        begin
            { UNIX argument file identifiers, for gpc compatibility }
            {==
            argv (1, NstdIdentifiers);
            argv (2, NscanSsl);
            argv (3, NparseSsl);
            argv (4, Nsource);
            argv (5, NparseStream);
            argv (6, Noptions);
            ==}

            errorCount := 0;
            lineNumber := 1;
            nextLineNumber := 1;
            newInputLine := false;
            abort := false;

            { Initialize special character values }
            backslash := chr(92);       { ASCII \ }
            newline := chr(10);         { ASCII NL / LF }
            carriagereturn := chr(13);  { ASCII CR }

            { Initialize charClassMap }
            i := 0;
            while i <= charSetSize do
                begin
                    charClassMap[i] := lIllegal;
                    i := i + 1
                end;

            { N.B. The following code assumes that decimal digit characters 
              (this remark applies also to upper and lower case alphabetic characters) 
              are consecutive in the collating sequence.  If this is not a valid assumption 
              for the character set at hand, then the code must be modified to classify 
              only the appropriate characters as members of the digit (letter) class. }
            Assert((ord('9') - ord('0') = 9), assert14);
            i := ord('0');
            repeat
                charClassMap[i] := lDigit;
                i := i + 1
            until i > ord('9');

            Assert((ord('Z') - ord('A') = 25), assert15);
            i := ord('A');
            repeat
                charClassMap[i] := lLetter;
                i := i + 1
            until i > ord('Z');

            Assert((ord('z') - ord('a') = 25), assert16);
            i := ord('a');
            repeat
                charClassMap[i] := lLetter;
                i := i + 1
            until i > ord('z');

            charClassMap[ord(tab)] := lTab;
            charClassMap[ord(blank)] := lBlank;
            charClassMap[ord(quote)] := lQuote;
            charClassMap[ord(backslash)] := lBackslash;
            charClassMap[ord(carriagereturn)] := lCarriageReturn;
            charClassMap[ord('(')] := lLeftParen;
            charClassMap[ord(')')] := lRightParen;
            charClassMap[ord('*')] := lStar;
            charClassMap[ord('+')] := lPlus;
            charClassMap[ord(',')] := lComma;
            charClassMap[ord('-')] := lMinus;
            charClassMap[ord('.')] := lDot;
            charClassMap[ord(':')] := lColon;
            charClassMap[ord(';')] := lSemicolon;
            charClassMap[ord('<')] := lLeftAngle;
            charClassMap[ord('=')] := lEquals;
            charClassMap[ord('>')] := lRightAngle;
            charClassMap[ord('[')] := lLeftBracket;
            charClassMap[ord(']')] := lRightBracket;
            charClassMap[ord('{')] := lLeftBrace;
            charClassMap[ord('}')] := lRightBrace;

            { Initialize the scan ssl table }
            reset(scanSsl {==, NscanSsl ==} );
            i := 0;
            while not eof(scanSsl) do
                begin
                    if i > scanTableSize then
                        Assert(false, assert2);
                    read(scanSsl, scanTable[i]);
                    i := i + 1
                end;

            { Initialize the parse ssl table }
            reset(parseSsl {==, NparseSsl ==} );
            i := 0;
            while not eof(parseSsl) do
                begin
                    if i > parseTableSize then
                        Assert(false, assert3);
                    read(parseSsl, parseTable[i]);
                    i := i + 1
                end;

            { Accept options }
            scanonly := false;
            scantracing := false;
            parsetracing := false;
            significantIdentTextSize := maxIdentifierLength;
            reset (options {==, Noptions ==} );

            while not eof(options) do
                begin
                    read (options, c);
                    if c = 'o' then
                        begin
                            read (options, c);
                            scanonly := (c = '1');
                        end
                    else if c = 't' then
                        begin
                            read (options, c);
                            scantracing := (c = '1');
                            parsetracing := (c = '2');
                        end
                    else if (c >= '0') and (c <= '9') then
                        begin
                            significantIdentTextSize := ord(c) - ord('0');
                            read(options, c);
                            significantIdentTextSize := significantIdentTextSize
                                                * 10 + ord(c) - ord('0');
                            if (significantIdentTextSize < minSignificantChars) or
                               (significantIdentTextSize > maxIdentifierLength) then
                                begin
                                    Error(eOptionsError);
                                    significantIdentTextSize := maxIdentifierLength
                                end
                        end
                end;

            { Initialize the ident table }
            i := 1;
            while i <= identTableSize do
                begin
                    identTextIndex[i] := null;
                    identTokenValue[i] := null;
                    i := i + 1
                end;

            { The standard identifiers file contains the text of all keywords and 
              predeclared identifiers.  Each identifier is followed by a newline marker.  
              Keywords are assumed to precede predeclared identifiers and the order of
              the keywords in the file must match the order in the parser's keyword 
              token list in parser.ssl . }
            reset(stdIdentifiers {==, NstdIdentifiers  ==});
            numberOfIdents := 0;
            identTextEnd := 0;
            numberStdIdentifiers := 0;
            while (numberStdIdentifiers <= maxStdIdentifiers) and not eof(stdIdentifiers) do
                begin
                    tokenTextLength := 0;
                    while not eoln(stdIdentifiers) do
                        begin
                            tokenTextLength := tokenTextLength + 1;
                            read(stdIdentifiers, textBuffer[tokenTextLength]);
                        end;

                    { Strip trailing spaces in stdIdentifiers }
                    while (tokenTextLength > 0) and (textBuffer[tokenTextLength] = ' ') do
                        tokenTextLength := tokenTextLength - 1;

                    if tokenTextLength > significantIdentTextSize then
                        significantChars := significantIdentTextSize
                    else
                        significantChars := tokenTextLength;

                    { Ignore blank lines and comments in stdIdentifiers }
                    if (tokenTextLength <> 0) and (textBuffer[1] <> '%') then
                        begin
                            IdentLookup;
                            numberStdIdentifiers := numberStdIdentifiers + 1;
                        end;

                    readln(stdIdentifiers);
                end;

            { Make sure we read them all }
            Assert((eof(stdIdentifiers)), assert17);

            { Initialize scanner table walker }
            scanTablePointer := 0;
            scanCallStackTop := 0;

            { Prepare input of PT source program and output of parse stream }
            reset(source {==, Nsource ==} );
            inputChar := blank;
            AcceptScanToken;
            rewrite(parseStream {==, NparseStream ==} );

        end { Initialize };


    procedure ScreenIdentifier;
        { Enforce limits on the number of significant characters in identifiers, 
          enter identifiers into the ident table and distinguish keywords from other identifiers. }
        var
            i: integer;

        begin
            if tokenTextLength > maxIdentifierLength then
                begin
                    Error(eIdentifierTooLong);
                    tokenTextLength := maxIdentifierLength
                end;

            { Mark the number of significant characters in the text buffer for use in IdentLookup, 
              IdentEnter and IdentCompare. }
            if tokenTextLength > significantIdentTextSize then
                significantChars := significantIdentTextSize
            else
                significantChars := tokenTextLength;

            { Convert all identifiers letters to lower case 
              since upper and lower case are considered equivalent. }
            i := 0;
            while i < tokenTextLength do
                begin
                    i := i + 1;
                    if (textBuffer[i] >= 'A') and (textBuffer[i] <= 'Z') then
                        textBuffer[i] := chr(ord(textBuffer[i]) - ord('A') + ord('a'));
                end;

            IdentLookup;

            if identTokenValue[hashValue] <= 0 then
                { Replace the identifier token by its keyword value }
                parseInputToken := identTokenValue[hashValue] + lastKeywordToken
            else
                { Set the value of a compound user defined identifier token }
                parseTokenValue := identTokenValue[hashValue];

        end { ScreenIdentifier };


    procedure ScreenInteger;
        { Set the value of an integer token, truncating if it exceeds the maximum 
          implementation values. }
        var
            digit: 0 .. 9;
            i: 1 .. textBufferSize;

        begin
            parseTokenValue := 0;
            i := 1;
            while i <= tokenTextLength do
                begin
                    digit := ord(textBuffer[i]) - ord('0');

                    (*
                    if (parseTokenValue > maxIntDivTen) or
                           ((parseTokenValue = maxIntDivTen) and (digit > maxIntModTen)) then
                        { Integer value is too large }
                        begin
                            Error(eIntegerOverflow);
                            parseTokenValue := maxInteger;
                            i := tokenTextLength  { exit the while loop }
                        end
                    else
                    *)
                        parseTokenValue := parseTokenValue * 10 + digit;

                    i := i + 1
                end

        end { ScreenInteger };


    procedure ScreenStringLiteral;
        { Evaluate special characters in a string literal }
        var
            i : integer;
            j : integer;

        begin
            { Convert escaped characters to their represented values }
            i := 0;
            j := 0;
            while i < tokenTextLength do
                begin
                    i := i + 1;
                    if textBuffer[i] = backslash then
                        begin
                            i := i + 1;
                            if textBuffer [i] = 'n' then
                                textBuffer[i] := newline
                            else if textBuffer [i] = 'r' then
                                textBuffer[i] := carriagereturn
                            else if textBuffer [i] = 't' then
                                textBuffer[i] := tab;
                        end;
                    j := j + 1;
                    textBuffer[j] := textBuffer[i];
                end;

            tokenTextLength := j

        end { ScreenStringLiteral };


    procedure ScanSSLChoice(choiceTag: integer;
                            var choiceTagMatched: Boolean);
        { This procedure performs both input and semantic choices.  
          It sequentially tests each alternative value against the tag value, 
          and when a match is found, performs a branch to the corresponding alternative path.  
          If none of the alternative values matches the tag value, sslTable interpretation
          proceeds to the operation immediately following the list of alternatives 
          (normally the otherwise path).  The flag choiceTagMatched is set to true
          if a match is found and false otherwise.                }
        var
            numberOfChoices: integer;

        begin
            scanTablePointer := scanTablePointer + scanTable[scanTablePointer];
            numberOfChoices := scanTable[scanTablePointer];
            scanTablePointer := scanTablePointer + 1;
            choiceTagMatched := false;

            while numberOfChoices > 0 do
                begin
                    if scanTable[scanTablePointer] = choiceTag then
                        begin
                            scanTablePointer := scanTablePointer + 1;
                            scanTablePointer := scanTablePointer - scanTable[scanTablePointer];
                            choiceTagMatched := true;
                            numberOfChoices := 0;
                        end
                    else
                        begin
                            scanTablePointer := scanTablePointer + 2;
                            numberOfChoices := numberOfChoices - 1
                        end
                end;

            if scantracing then
                begin
                    write ('Choice tag ', choiceTag: 1);
                    if choiceTagMatched then
                        write (' (matched)')
                    else
                        write (' (not matched)');
                    writeln
                end

        end { ScanSSLChoice };


    procedure SSLTrace(walkerName: PhaseNames;  tablePointer: integer;
                       operation: integer;  argument: integer);
        begin
            write ('Table index ', tablePointer-1: 1, ';  Operation ',
                operation: 1, ';  Argument ', argument: 1);
            writeln;
        end { SSLTrace };


    procedure Scanner;
        { The scanner removes token separators from the source program text 
          (blanks, newlines, tabs, comments) and breaks the program up into syntax tokens.  
          The scanner operates as a coroutine with the parser.  Each time it is activated, 
          it scans a single token before passing control back to the parser. }
        var
            operation: integer;
            choiceTagMatched: Boolean;

            { Flag buffer overflows so only a single error message is emitted }
            textBufferOverflow: Boolean;


        { S/SL table walker }
        begin
            tokenTextLength := 0;
            scanning := true;
            textBufferOverflow := false;

            repeat
                operation := scanTable[scanTablePointer];
                scanTablePointer := scanTablePointer + 1;

                if scantracing then
                    SSLTrace(scan, scanTablePointer, operation, scanTable[scanTablePointer]);

                case operation of
                    oCall:
                        if scanCallStackTop < scanCallStackSize then
                            begin
                                scanCallStackTop := scanCallStackTop + 1;
                                scanCallStack[scanCallStackTop] := scanTablePointer + 1;
                                scanTablePointer := scanTable[scanTablePointer];
                            end
                          else
                            { The scanner S/SL contains no
                              recursion so this shouldn't happen }
                            Assert(false, assert4);

                    oReturn:
                        if scanCallStackTop > 0 then
                            begin
                                scanTablePointer := scanCallStack[scanCallStackTop];
                                scanCallStackTop := scanCallStackTop - 1
                            end
                          else
                            scanning := false;        { normal exit }

                    oRuleEnd:
                        { No rule choices in scanner }
                        Assert(false, assert5);

                    oJumpForward:
                        scanTablePointer := scanTablePointer + scanTable[scanTablePointer];

                    oJumpBack:
                        scanTablePointer := scanTablePointer - scanTable[scanTablePointer];

                    oInput:
                        { No forced inputs in scanner }
                        Assert(false, assert6);

                    oInputAny:
                        if scanToken <> lEndFile then
                            AcceptScanToken
                        else
                            { premature end of file }
                            begin
                                Error(eSyntaxError);
                                Error(ePrematureEOF);
                            end;

                    oInputChoice:
                        begin
                            ScanSSLChoice(scanToken, choiceTagMatched);
                            if choiceTagMatched then
                                AcceptScanToken
                        end;

                    oEmit:
                        begin
                            parseInputToken := scanTable[scanTablePointer];
                            scanTablePointer := scanTablePointer + 1;
                            { Return control to the parser }
                            scanning := false
                        end;

                    oError:
                        begin
                            Error (scanTable[scanTablePointer]);
                            scanTablePointer := scanTablePointer + 1;
                        end;

                    oChoice:
                        { No choices in scanner }
                        Assert(false, assert7);

                    oChoiceEnd:
                        Assert(false, assert8);

                    oSetParameter:
                        { No parameterized operations in scanner }
                        Assert(false, assert9);

                    oSetResult:
                        { No choice operations in scanner }
                        Assert(false, assert10);


                    { Semantic Operations of the Buffer Mechanism }
                    
                    oBufferSave:
                        { Save the last accepted character in
                          a text buffer for later reference. }
                        if tokenTextLength < textBufferSize then
                            begin
                                tokenTextLength := tokenTextLength + 1;
                                textBuffer[tokenTextLength] := lastInputChar
                            end
                        else
                            { Set a flag rather than calling Error 
                              to avoid a string of consecutive messages. }
                            textBufferOverflow := true;

                end { case operation };

            until not scanning;

            if textBufferOverflow then
                Error(eTextBufferOverflow)

        end { Scanner };


    procedure ScannerScreener;
        { Invoke the scanner to find the next syntax token in the source program.  
          The token returned is left in parseInputToken.  The value of a compound token 
          is left in parseTokenValue and the characters comprising a literal string 
          are left in textBuffer.  Resolve identifiers and keywords, and enforce limits 
          on identifier lengths and integer values.                      }

        var
            i: integer;

        begin
            Scanner;

            if parseInputToken = pIdentifier then
                ScreenIdentifier
            else if parseInputToken = pInteger then
                ScreenInteger
            else if parseInputToken = pStringLiteral then
                ScreenStringLiteral;

            if scantracing then
                begin
                    write ('Output token emitted ', parseInputToken: 1);
                    writeln;

                    if (parseInputToken >= firstCompoundInputToken) and
                            (parseInputToken <= lastCompoundInputToken) then
                        begin
                            write ('% Output token text ''');
                            i := 1;
                            while (i <= tokenTextLength) do
                                begin
                                    write (textBuffer [i]);
                                    i := i + 1;
                                end;
                            write ('''');
                            writeln;
                        end
                end

        end { ScannerScreener };


    procedure ParseSSLChoice (choiceTag: integer;
                              var choiceTagMatched: Boolean);
        { See comment under ScanSSLChoice }
        var
            numberOfChoices: integer;

        begin
            parseTablePointer := parseTablePointer + parseTable[parseTablePointer];
            numberOfChoices := parseTable[parseTablePointer];
            parseTablePointer := parseTablePointer + 1;
            choiceTagMatched := false;

            while numberOfChoices > 0 do
                begin
                    if parseTable[parseTablePointer] = choiceTag then
                        begin
                            parseTablePointer := parseTablePointer + 1;
                            parseTablePointer :=  parseTablePointer - parseTable[parseTablePointer];
                            choiceTagMatched := true;
                            numberOfChoices := 0
                        end
                    else
                        begin
                            parseTablePointer := parseTablePointer + 2;
                            numberOfChoices := numberOfChoices - 1
                        end
                end;

            if parsetracing then
                begin
                    write ('Choice tag ', choiceTag: 1);
                    if choiceTagMatched then
                        write (' (matched)')
                    else
                        write (' (not matched)');
                    writeln
                end

        end { ParseSSLChoice };


    procedure EmitOutputToken (emittedToken: integer);
        { Emit an output token to the parse stream }
        var
            i: integer;

        begin
            write (parseStream, emittedToken);

            if parsetracing then
                begin
                    write ('Output token emitted ', emittedToken: 1);
                    writeln;
                end;

            { Emit the value associated with a compound token.
              N.B. this code assumes that the compound token being emitted 
              was the last compound token accepted. }
            if (emittedToken = sIdentifier) or (emittedToken = sInteger) then
                write(parseStream, compoundTokenValue)
            else if emittedToken = sStringLiteral then
                { Emit the text of a literal string token }
                begin
                    write(parseStream, compoundTokenLength);
                    i := 1;
                    while i <= compoundTokenLength do
                        begin
                            write(parseStream, ord(compoundTokenText[i]));
                            i := i + 1
                        end
                end;

        end { EmitOutputToken };


    procedure AcceptSyntaxToken;
        { This procedure provides the interface to the ScannerScreener;  
          it is responsible for handling all input including line number indicators and
          the values and text associated with input tokens. }
        var
            acceptedToken: SyntaxToken;
            i: integer;

        begin
            Assert(parseInputToken <> pEndFile, assert11);

            { Accept Token }
            acceptedToken := parseInputToken;

            if (acceptedToken >= firstCompoundInputToken) and
                   (acceptedToken <= lastCompoundInputToken) then
                begin
                    compoundToken := acceptedToken;
                    compoundTokenValue := parseTokenValue;
                    compoundTokenLength := tokenTextLength;

                    if acceptedToken = pStringLiteral then
                        begin
                            i := 1;
                            while i <= compoundTokenLength do
                                begin
                                    compoundTokenText[i] := textBuffer[i];
                                    i := i + 1
                                end
                        end
                end;

            { Update Line Number }
            lineNumber := nextLineNumber;

            { Read Next Input Token }
            newInputLine := false;
            repeat
                ScannerScreener;

                if parseInputToken = pNewLine then
                    begin
                        { Update Line Counter and Set Flag }
                        newInputLine := true;

                        if nextLineNumber < maxLineNumber then
                            nextLineNumber := nextLineNumber + 1
                        else
                            nextLineNumber := 0;

                        { Pass line markers to the next pass }
                        EmitOutputToken(sNewLine);
                    end;
            until parseInputToken <> pNewLine;

            if parsetracing then
                begin
                    write ('Input token accepted ', acceptedToken: 1,
                        ';  Line ', lineNumber: 1, ';  Next input token ',
                        parseInputToken: 1);
                    writeln
                end

        end { AcceptSyntaxToken };


    { Syntax Error Handling }

    procedure SslGenerateCompoundInputToken (expectedToken: SyntaxToken);
        begin
            Assert ((parseInputToken = pSyntaxError) or
                    (parseInputToken = pEndFile), assert12);

            case expectedToken of
                pInteger:
                    compoundTokenValue := 0;
                pIdentifier:
                    compoundTokenValue := defaultIdentifier;
                pStringLiteral:
                    begin
                        compoundTokenLength := 1;        { literal length }
                        compoundTokenText[1] := '?';
                    end
            end;

        end { SslGenerateCompoundInputToken };


    procedure SslSyntaxError;
        { This procedure handles syntax errors in the input to the Parser pass; 
          for Semantic passes this procedure will simply assert false since a syntax error in
          input would indicate an error in the previous pass. }

        { Syntax error recovery:
          When a mismatch occurs between the the next input token and the syntax table, 
          the following recovery is employed. }

        { If the expected token is pNewLine then if there has been no previous syntax error 
          on the line, ignore the error.  (A missing logical new line is not a real error.) }

        { If the expected token is pNewLine or pSemicolon and a syntax error has already been 
          detected on the current logical line (flagged by parseInputToken = pSyntaxError), 
          then flush the input until a new line or end of file is found. }

        { Otherwise, if this is the first syntax error detected on the line 
          (flagged by parseInputToken <> pSyntaxError), then if the input token is pEndFile 
          then emit the ePrematureEOF error code and terminate execution.  
          Otherwise, emit the eSyntaxError error code and set the parseInputToken to pSyntaxError 
          to prevent further input until the expected input is pSemicolon or pNewLine. }

        { If the expected token is not pSemicolon nor pNewLine and a syntax error has already been
          detected on the current line (flagged by parseInputToken = pSyntaxError), 
          then do nothing and continue as if the expected token had been matched. }

        begin
            Assert ((parserOperation = oInput) or
                    (parserOperation = oInputAny), assert13);

            if parseInputToken = pSyntaxError then
                begin
                    { Currently recovering from syntax error }
                    if parseTable[parseTablePointer] = pSemicolon then
                        begin
                            { Complete recovery by synchronizing
                             input to a new line                 }
                            parseInputToken := savedInputToken;
                            newInputLine := false;

                            while (parseInputToken <> pSemicolon) and
                                  (parseInputToken <> pEndFile) and
                                  not newInputLine do
                                AcceptSyntaxToken;

                            { If we now have the expected token, accept it }
                            if parseInputToken = pSemicolon then
                                AcceptSyntaxToken;
                        end;
                end
            else
                { First syntax error on the line }
                if parseInputToken = pEndFile then
                    begin
                        { Flag error and terminate parsing }
                        Error (ePrematureEOF);
                        parsing := false;
                    end
                else
                    begin
                        { Flag error and begin recovery }
                        Error (eSyntaxError);
                        savedInputToken := parseInputToken;
                        parseInputToken := pSyntaxError;
                        lineNumber := nextLineNumber;
                    end;

            { If the expected input token is a compound 
             token, generate a dummy one.                }
            if (parseTable[parseTablePointer] >= firstCompoundInputToken) and
                   (parseTable[parseTablePointer] <= lastCompoundInputToken) then
                SslGenerateCompoundInputToken (parseTable[parseTablePointer]);

        end { SslSyntaxError };


    procedure ScannerOnly;
        { Used only when "scan only" (-o1) is specified.    }
    begin
        { For scan only mode, simply accept input tokens. }
        parseInputToken := pNewLine;
        newInputLine := false;

        while parseInputToken <> pEndFile do
            AcceptSyntaxToken;

    end { ScannerOnly };


    procedure Parser;
        { The parser checks that the source program is syntactically legal,
          flagging syntax errors and repairing them. The parser passes control to the Scanner 
          (the Scanner and Parser are coroutines) whenever it requires a new token.  
          It emits a stream representing the parsed program in postfix form to the semantic pass. }
        const
            parseCallStackSize = 63;
        var
            { Parameterized And Choice Semantic Operation Values:
              These are used to hold the decoded parameter value to a parameterized 
              semantic operation and the result value returned by a choice semantic operation
              or rule respectively. }
            parameterValue: integer;
            resultValue: integer;

            { Flag for result of choices }
            choiceTagMatched: Boolean;

            { Saved return addresses for S/SL call operations }
            parseCallStack: array [1 .. parseCallStackSize] of integer;
            parseCallStackTop: 0 .. parseCallStackSize;

        begin
            { Initialize Parse Table Walker State }
            parsing := true;
            parseTablePointer := 0;
            parseCallStackTop := 0;

            { Initialize token input from Scanner }
            parseInputToken := pNewLine;
            newInputLine := false;
            AcceptSyntaxToken;

            { Walk the S/SL Table }
            while parsing do
                begin
                    parserOperation := parseTable[parseTablePointer];
                    parseTablePointer := parseTablePointer + 1;

                    { Trace Execution }
                    if parsetracing then
                        SSLTrace(parse, parseTablePointer, parserOperation,
                                 parseTable[parseTablePointer]);

                    case parserOperation of
                        oCall:
                            if parseCallStackTop < parseCallStackSize then
                                begin
                                    parseCallStackTop := parseCallStackTop + 1;
                                    parseCallStack[parseCallStackTop] := parseTablePointer + 1;
                                    parseTablePointer := parseTable[parseTablePointer];
                                end
                              else
                                begin
                                    Error (eParseCallStackOvfl);
                                    parsing := false;
                                end;

                        oReturn:
                            if parseCallStackTop = 0 then
                                { Return from main S/SL rule }
                                parsing := false
                            else
                                begin
                                    parseTablePointer := parseCallStack[parseCallStackTop];
                                    parseCallStackTop := parseCallStackTop - 1;
                                end;

                        oRuleEnd:
                            SslFailure (fChoiceRuleFailed);

                        oJumpForward:
                            parseTablePointer := parseTablePointer + parseTable[parseTablePointer];

                        oJumpBack:
                            parseTablePointer := parseTablePointer - parseTable[parseTablePointer];

                        oInput:
                            begin
                                if parseTable[parseTablePointer] = parseInputToken then
                                    AcceptSyntaxToken
                                else
                                    { Syntax error in input }
                                    SslSyntaxError;

                                parseTablePointer := parseTablePointer + 1;
                            end;

                        oInputAny:
                            if parseInputToken <> pEndFile then
                                AcceptSyntaxToken
                            else
                                { Premature end of file }
                                SslSyntaxError;

                        oInputChoice:
                            begin
                                ParseSSLChoice (parseInputToken, choiceTagMatched);

                                if choiceTagMatched then
                                    AcceptSyntaxToken;
                            end;

                        oEmit:
                            begin
                                EmitOutputToken (parseTable[parseTablePointer]);
                                parseTablePointer := parseTablePointer + 1;
                            end;

                        oError:
                            begin
                                Error (parseTable[parseTablePointer]);
                                parseTablePointer := parseTablePointer + 1;
                            end;

                        oChoice:
                            ParseSSLChoice (resultValue, choiceTagMatched);

                        oChoiceEnd:
                            SslFailure (fSemanticChoiceFailed);

                        oSetParameter:
                            begin
                                parameterValue := parseTable[parseTablePointer];
                                parseTablePointer := parseTablePointer + 1;
                            end;

                        oSetResult:
                            begin
                                resultValue := parseTable[parseTablePointer];
                                parseTablePointer := parseTablePointer + 1;
                            end;

                    end { case parserOperation };

                end { while parsing };

            if (parseInputToken <> pEndFile) and (errorCount = 0) and not abort then
                Error (eSyntaxError);
                { Error (eExtraneousSource); }

        end { Parser };


    { Main program ScannerParser }
    begin
        Initialize;

        if scanonly then
            ScannerOnly
        else
            Parser;

        { No sense running semantic phase if serious syntax errors found }
        if (errorCount > 0) or scanonly then
            rewrite(parseStream {==, NparseStream ==} );
    end.  { ScannerParser }
