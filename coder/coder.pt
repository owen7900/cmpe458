{  PT Code Generator for Linux x86 Version 5.1
 
   Date:  30 Jun 1980
          (Linux x86 conversion Jan 2011)
          {Revised v5.1 - 8 Feb 2021)
 
   Author:  Alan Rosselet, University of Toronto
            VAX, SUN, MIPS and x86 conversions by J.R. Cordy, Queen's University
            SUN SPARC conversion by T.R. Dean, Queen's University

   Abstract:
     The code generator translates PT intermediate code, tcode, into Linux x86 assembly code.  
     The only interface to the preceding pass is the tcode stream.  Data allocation has already 
     been done by the semantic analysis pass with variable addresses passed in the tcode.
     The coder attempts to produce locally good code by maintaining a stack of data descriptors 
     which mimic the contents of the runtime stack during expression processing.  
     The coder translates Boolean expressions into control flow.

   Input Files
        SslFile: S/SL table generator from coder.ssl
        options: Compiler options
        tCode:   TCode instructions generated by the semantic analysis pass for the source program.

   Output Files
        object:  Object x86 assembly code
        output:  diagnostic messages.
}


program Coder (output, coderSsl, tCode, object, options);

    const

{ ===== Pasted contents of coder.def, generated by S/SL from coder.ssl -
        defines Semantic Operations, Input/Output Tokens, Error Codes and Semantic Types }

        { Semantic Operations }
        oTempAllocate = 14;
        oTempFree = 15;
        oOperandPushMode = 16; { (16) }
        oOperandChooseMode = 17; { >>16 }
        oOperandPushVariable = 18;
        oOperandPushInteger = 19;
        oOperandPushChar = 20;
        oOperandPushBoolean = 21;
        oOperandPushJumpCondition = 22; { (15) }
        oOperandChooseJumpCondition = 23; { >>15 }
        oOperandPushStringAddress = 24;
        oOperandPushProcedure = 25;
        oOperandPushTrap = 26;
        oOperandPushCaseLow = 27;
        oOperandPushCaseHigh = 28;
        oOperandPushArrayLowerBound = 29;
        oOperandPushArrayUpperBound = 30;
        oOperandPushCopy = 31;
        oOperandPushTemp = 32;
        oOperandSetMode = 33; { (16) }
        oOperandSetLength = 34; { (13) }
        oOperandSetRegnum = 35; { (13) }
        oOperandChooseLength = 36; { >>13 }
        oOperandSetValue = 37; { (13) }
        oOperandChooseValue = 38; { >>13 }
        oOperandChooseManifestValue = 39; { >>13 }
        oOperandIsValueNegative = 40; { >>14 }
        oOperandEnterValueFromCaseTableAddress = 41;
        oOperandEnterValueFromCodeAddress = 42;
        oOperandEnterValueFromDataAreaSize = 43;
        oOperandCompareLeftAndRight = 44; { >>14 }
        oOperandCompareRightAndDest = 45; { >>14 }
        oOperandIsJumpCondition = 46; { >>14 }
        oOperandComplementJumpCondition = 47;
        oOperandAddManifestValues = 48;
        oOperandSubtractManifestValues = 49;
        oOperandMultiplyManifestValues = 50;
        oOperandNegateManifestValue = 51;
        oOperandCompareManifestValues = 52; { >>14 }
        oOperandMergeShuntsWithAddress = 53;
        oOperandMergeShunts = 54;
        oOperandFoldManifestSubscript = 55;
        oOperandSwap = 56;
        oOperandSwapRightAndDest = 57;
        oOperandSwapLeftAndDest = 58;
        oOperandPop = 59;
        oFixPushAddress = 60;
        oFixPushLastAddress = 61;
        oFixSwapAddresses = 62;
        oFixAndFreeShuntList = 63;
        oFixAndFreeFalseBranches = 64;
        oFixForwardBranch = 65;
        oFixPopAddress = 66;
        oEmitProcLabel = 67; { (16) }
        oEmitNone = 68; { (17) }
        oEmitSingle = 69; { (17) }
        oEmitDouble = 70; { (17) }
        oEmitString = 71;
        oEmitConditionalForwardBranch = 72;
        oEmitUnconditionalForwardBranch = 73;
        oEmitConditionalBackwardBranch = 74;
        oEmitUnconditionalBackwardBranch = 75;
        oEmitSourceCoordinate = 76;
        oEmitMergeSourceCoordinate = 77;
        oEmitCaseMergeBranch = 78;
        oEmitCaseBranchTable = 79;
        oCasePush = 80;
        oCasePop = 81;
        oCaseEnterTCodeAddress = 82;
        oCaseEnterVariantAddress = 83;
        oCaseEnterMergeAddress = 84;
        oCaseEnterAbortAddress = 85;
        oArrayEnterLowerBound = 86;
        oArrayEnterUpperBound = 87;
        oOptionTestChecking = 88; { >>14 }

        { Input Tokens }
        tMultiply = 0;
        firstTcode = 0;
        tDivide = 1;
        tModulus = 2;
        tAdd = 3;
        tSubtract = 4;
        tEQ = 5;
        tNE = 6;
        tGT = 7;
        tGE = 8;
        tLT = 9;
        tLE = 10;
        tAnd = 11;
        tInfixAnd = 12;
        tOr = 13;
        tInfixOr = 14;
        tNegate = 15;
        tNot = 16;
        tChr = 17;
        tOrd = 18;
        tEoln = 19;
        tEOF = 20;
        tVarParm = 21;
        tFetchAddress = 22;
        tFetchInteger = 23;
        tFetchChar = 24;
        tFetchBoolean = 25;
        tAssignBegin = 26;
        tAssignAddress = 27;
        tAssignInteger = 28;
        tAssignChar = 29;
        tAssignBoolean = 30;
        tStoreAddress = 31;
        tStoreInteger = 32;
        tStoreChar = 33;
        tStoreBoolean = 34;
        tSubscriptBegin = 35;
        tSubscriptAddress = 36;
        tSubscriptInteger = 37;
        tSubscriptChar = 38;
        tSubscriptBoolean = 39;
        tArrayDescriptor = 40;
        tFileDescriptor = 41;
        tFileBind = 42;
        tIfBegin = 43;
        tIfEnd = 44;
        tCaseBegin = 45;
        tWhileBegin = 46;
        tRepeatBegin = 47;
        tRepeatControl = 48;
        tCallBegin = 49;
        tParmEnd = 50;
        tProcedureEnd = 51;
        tWriteBegin = 52;
        tReadBegin = 53;
        tTrapBegin = 54;
        tWriteEnd = 55;
        tReadEnd = 56;
        tLiteralAddress = 57;
        firstCompoundTcode = 57;
        tLiteralInteger = 58;
        tLiteralChar = 59;
        tLiteralBoolean = 60;
        tSkipString = 61;
        tStringData = 62;
        tLiteralString = 63;
        tIfThen = 64;
        tIfMerge = 65;
        tCaseSelect = 66;
        tCaseMerge = 67;
        tCaseEnd = 68;
        tWhileTest = 69;
        tWhileEnd = 70;
        tRepeatTest = 71;
        tSkipProc = 72;
        tCallEnd = 73;
        tLineNumber = 74;
        tTrap = 75;
        lastCompoundTcode = 75;
        tEndOfFile = 76;
        lastTcode = 76;

        { Output Tokens }

        { Input/Output Tokens }

        { Error Codes }
        eDivisionByZero = 10;
        firstErrorCode = 10;
        lastSslErrorCode = 10;

        { Type Values }
        { Type 13 }
        minusOne = -1;
        zero = 0;
        null = 0;
        one = 1;
        two = 2;
        four = 4;
        eight = 8;
        twelve = 12;
        regAX = 1;
        regBX = 2;
        regCX = 3;
        regDX = 4;
        trHalt = 0;
        trReset = 1;
        trRewrite = 2;
        trRead = 3;
        trReadln = 4;
        trWrite = 5;
        trWriteln = 6;
        trWriteString = 7;
        trWriteInteger = 8;
        trWriteChar = 9;
        trReadInteger = 10;
        trReadChar = 11;
        trAssign = 12;
        trSubscriptAbort = 13;
        trCaseAbort = 14;
        trEoln = 15;
        trEof = 16;
        byte = 1;
        word = 2;
        { Type 14 }
        no = 0;
        yes = 1;
        { Type 15 }
        iJalways = -9;
        iJhi = -8;
        iJlos = -7;
        iJge = -6;
        iJlt = -5;
        iJle = -4;
        iJgt = -3;
        iJne = -2;
        iJeq = -1;
        iJnever = 0;
        { Type 16 }
        mStatic = 1;
        mStaticManifest = 2;
        mTemp = 3;
        mTempIndirect = 4;
        mTempIndirectCaseOffset = 5;
        mStackReg = 6;
        mStack = 7;
        mBaseReg = 8;
        mArgument = 9;
        mManifest = 10;
        mResultReg = 11;
        mRemainderReg = 12;
        mScratchReg1 = 13;
        mScratchReg2 = 14;
        mGlobalBase = 15;
        mLineNum = 16;
        mMainProc = 17;
        mProc = 18;
        mTrap = 19;
        mWord = 20;
        { Type 17 }
        iAdd = 1;
        iCmp = 2;
        iDec = 3;
        iDiv = 4;
        iInc = 5;
        iMul = 6;
        iShl = 7;
        iNeg = 8;
        iSub = 9;
        iMov = 10;
        iPush = 11;
        iPop = 12;
        iLoada = 13;
        iExtend = 14;
        iJmp = 15;
        iCall = 16;
        iReturn = 17;
        iEnter = 18;
        iLeave = 19;
        iGlobl = 20;
        iText = 21;
        iData = 22;
        iWord = 23;
        iSpace = 24;

        { S/SL Rule Table Addresses } {
        Program = 0;
        EmitProgramPrologue = 7;
        Block = 65;
        EmitProgramEpilogue = 58;
        OperandAssignIntegerPopPop = 3142;
        Routine = 143;
        Statements = 249;
        OperandNextArgument = 234;
        OperandAssignCharPopPop = 3165;
        OperandAssignBooleanPopPop = 3175;
        AssignStmt = 311;
        CallStmt = 319;
        IfStmt = 394;
        WhileStmt = 558;
        RepeatStmt = 616;
        CaseStmt = 648;
        WriteProc = 780;
        ReadProc = 864;
        TrapStmt = 955;
        OperandPushVariable = 1268;
        OperandPushExpressionAssignPopPop = 1830;
        OperandPushExpression = 1073;
        OperandConvertJumpConditionToData = 3212;
        OperandForceAddressIntoTemp = 3562;
        OperandForceToStack = 3714;
        OperandPopAndFreeTemp = 3187;
        OperandPushBooleanControlExpression = 448;
        FoldIfStmt = 489;
        OperandComplementJumpCondition = 3078;
        OperandInfixOr = 3104;
        OperandForceToJumpCondition = 453;
        EmitTst = 3919;
        SkipToEndIf = 539;
        SkipToEndWhile = 597;
        OperandFreeTemp = 3200;
        CaseSelect = 676;
        CaseVariant = 679;
        CaseEnd = 687;
        EmitDefaultCaseAbort = 697;
        EmitCaseSubscriptJump = 721;
        OperandForceIntoTemp = 3500;
        OperandSubtractRightFromLeftPop = 2289;
        WriteParameter = 795;
        ReadParameter = 879;
        EmitStringAddress = 1265;
        OperandNegate = 2114;
        OperandAddPop = 2192;
        OperandSubtractPop = 2311;
        OperandMultiplyPop = 2462;
        OperandDividePop = 2607;
        OperandModPop = 2632;
        OperandNot = 3073;
        OperandOrPop = 3126;
        OperandEqualPop = 3309;
        OperandGreaterPop = 3384;
        OperandLessPop = 3472;
        OperandChr = 2764;
        OperandOrd = 2770;
        OperandEolnFunction = 2794;
        OperandEofFunction = 2920;
        OperandSubscriptIntegerPop = 1335;
        OperandSubscriptCharPop = 1364;
        OperandSubscriptBooleanPop = 1396;
        OperandSubscriptNonManifestIntegerPop = 1428;
        OperandSubscriptNonManifestCharPop = 1692;
        OperandCheckedSubscriptNonManifestIntegerPop = 1441;
        OperandUncheckedSubscriptNonManifestIntegerPop = 1614;
        EmitSubscriptRangeCheck = 1559;
        OperandPushArrayLowerBound = 1526;
        OperandPushArrayUpperBound = 1540;
        EmitCmp = 3829;
        EmitSubscriptAbort = 1593;
        OperandCheckedSubscriptNonManifestCharPop = 1705;
        OperandUncheckedSubscriptNonManifestCharPop = 1777;
        OperandNegateAssignPopPop = 2089;
        OperandAddAssignPopPopPop = 2129;
        OperandSubtractAssignPopPopPop = 2269;
        OperandMultiplyAssignPopPopPop = 2354;
        OperandDivideAssignPopPopPop = 2561;
        OperandNotAssignPopPop = 2982;
        EmitMove = 3885;
        OperandAddRightToLeftPop = 2162;
        EmitAdd = 3799;
        OperandForceLeftIntoTemp = 3548;
        EmitSub = 3814;
        OperandMultiplyLeftByRightPop = 2387;
        OperandDivideLeftByRightPop = 2581;
        OperandEmitDividePopPop = 2657;
        SaveTempRegsToStack = 2856;
        RestoreTempRegsFromStack = 2888;
        OperandPushTrueTemp = 3277;
        OperandPushFalseTemp = 3293;
        OperandPushTempByte = 3705;
        OperandFoldComparisonPopPop = 3476;
        OperandPushTempWord = 3696;
        OperandForceAddressIntoNewTemp = 3624;
        OperandAreLeftAndRightManifest = 3741; >>14
        OperandLeftOrRightIsTemp = 3770; >>14
        }

        { S/SL Table Parameters }
        sslTblSize = 3954;
        minSslTableValue = -32767;
        maxSslTableValue = 32767;

{ ===== End of contents of coder.def }

        { S/SL table operations }
        firstTableOperation = 0;
        lastTableOperation = 120;

        { Primitive operations }
        oCall = 0;
        oReturn = 1;
        oRuleEnd = 2;
        oJumpBack = 3;
        oJumpForward = 4;
        oInput = 5;
        oInputAny = 6;
        oInputChoice = 7;
        oEmit = 8;
        oError = 9;
        oChoice = 10;
        oChoiceEnd = 11;
        oSetParameter = 12;
        oSetResult = 13;

       { firstFatalErrorCode MUST be bigger than lastSslErrorCode }
        firstFatalErrorCode = 50;
        eFixStackOvfl = 51;
        eOperandStkOvfl = 52;
        eSslStackOvfl = 54;
        eProcAddrTableOvfl = 55;
        eCaseLimitExceeded = 56;
        eArrayBoundsOvfl = 58;
        eCaseStackOvfl = 59;
        eShuntListExhausted = 60;
        eTooManyArguments = 61;
        eCountStackOvfl = 62;
        eFrameStackOvfl = 63;
        lastErrorCode = 63;

        { Type Values }
        firstOpCode = -9;
        lastJumpCode = 0;

        { S/SL System Failure Codes }
        firstFailureCode = 0;
        fSemanticChoiceFailed = 0;
        fChoiceRuleFailed = 1;
        lastFailureCode = 1;

        { Coder Limits }
        sslTableSize = 10000;
        maxInteger = 32767;
        minInteger = -32767;
        sslStackSize = 100;
        operandStkSize = 80;
        fixStackSize = 250;
        caseTableSize =  256;   { max number of alternatives in a case stmt }
        caseStackSize =  20;    { max nesting of case statements }
        maxShunts = 64;
        maxLiteralLength = 80;  { should match max in previous pass }
        maxArrayBounds = 200;
        memorySize = 32000;
        maxLineNumber = 9999;

        { Machine word size }
        wordSize = 4;           { longword (4 bytes) on SUN }

        { Temporary regs - %ebx, %ecx, %esi, %edi }
        firstTempReg = 1;       
        lastTempReg = 4;        

        { Misc }
        undefined = minInteger;

        { Assertion identification values }
        assert1 = 1;
        assert2 = 2;
        assert3 = 3;
        assert4 = 4;
        assert5 = 5;
        assert6 = 6;
        assert7 = 7;
        assert8 = 8;
        assert9 = 9;
        assert10 = 10;
        assert11 = 11;
        assert12 = 12;
        assert13 = 13;
        assert14 = 14;
        assert15 = 15;
        assert16 = 16;
        assert17 = 17;
        assert18 = 18;
        assert19 = 19;
        assert20 = 20;
        assert21 = 21;
        assert22 = 22;
        assert23 = 23;
        assert24 = 24;
        assert25 = 25;
        assert26 = 26;
        assert27 = 27;
        assert28 = 28;
        assert29 = 29;
        assert30 = 30;
        assert31 = 31;
        assert32 = 32;
        assert33 = 33;
        assert34 = 34;
        assert35 = 35;
        assert36 = 36;
        assert37 = 37;
        assert38 = 38;
        assert39 = 39;
        assert40 = 40;
        assert41 = 41;
        assert42 = 42;
        assert43 = 43;
        assert44 = 44;
        assert45 = 45;
        assert46 = 46;
        assert47 = 47;
        assert48 = 48;
        assert49 = 49;
        assert50 = 50;
        assert51 = 51;
        assert52 = 52;
        assert53 = 53;

    type
        ShuntRef = undefined .. maxShunts;
        OperandStkRef = 0 .. operandStkSize;
        InputTokens = firstTcode .. lastTcode;
        ErrorCodes = firstErrorCode .. lastErrorCode;
        FailureCodes = firstFailureCode .. lastFailureCode;

    var 
        { The Syntax/Semantic Table;
          The S/SL table file produced by the S/SL Processor 
          for the pass is read into this array during initialization. }
        sslTable: array [0 .. sslTableSize] of integer;
        coderSsl: file of integer;

        { Table Walker State }
        processing: Boolean             { initially true };
        sslPointer: 0 .. sslTableSize   { initially 0 };
        operation: firstTableOperation .. lastTableOperation;

        { Tracing Control }
        options: text;
        tracing: Boolean        { initially false };
        lineNumbering: Boolean  { initially true };
        checking: Boolean       { initially true };

        { Abort flag }
        abort: Boolean          { initially false };

        { The S/SL Rule Call Stack:
          The Rule Call Stack implements Syntax/Semantic Language rule call and return.
          Each time an oCall operation is executed, the table return address is pushed onto the
          Rule Call Stack.  When an oReturn is executed, the return address is popped from 
          the stack.  An oReturn executed when the Rule Call Stack is empty terminates 
          table execution. }
        sslStack: array [1 .. sslStackSize] of 0 .. sslTableSize;
        sslTop:   0 .. sslStackSize  { initially 0 };

        { Choice Match Flag:
          Set by the Choice Handler to indicate whether a match was made or the otherwise 
          path was taken.  Set to true if a match was made and false otherwise.
          This flag is used in input choices to indicate whether the choice input token 
          should be accepted or not. }
        choiceTagMatched: Boolean;

        { Parameterized And Choice Semantic Operation Values:
          These are used to hold the decoded parameter value to a parameterized semantic 
          operation and the result value returned by a choice semantic operation or rule 
          respectively. }
        parameterValue: integer;
        resultValue:    integer;

        { Line Counters }
        nextLineNumber: 0 .. maxLineNumber  { initially 0 };
        lineNumber:     0 .. maxLineNumber;
        lastEmittedLineNumber: integer;
        lastOpcode: integer;
            
        { Error Counter }
        noErrors: integer  { initially 0 };

        { Input Interface }
        tCode: file of integer;
        nextInputToken: InputTokens;

        { The Compound Input Token Buffer;
          When a compound input token is accepted from the input stream, 
          its associated value is saved in the compound token buffer for use by 
          the Semantic Mechanisms of the pass. }
        compoundToken: InputTokens;     { Last compound input token accepted }
        compoundTokenValue:  integer;   { Its associated value; often more than simply an integer }
        compoundTokenLength: integer;
        compoundTokenText:   array [1 .. maxLiteralLength] of integer;

        { tCaseEnd is a special compound token whose "value" consists of a lowest case label value,
          a highest case label value and a case branch table. }
        caseLow:  integer;
        caseHigh: integer;
        tCodeCaseTable: array [1 .. caseTableSize] of integer;

        { Output Interface }
        object: text;  { Object assembly code file }

        { Global Temporary }
        i: integer;

        { Temporary Mechanism }
        tempregfree: array [firstTempReg .. lastTempReg] of boolean;
        tempregnum:  integer;

        { Operand Stack }
        { The kind field can contain either an addressing mode or a jump condition (e.g. bne). }
        operandStkKind: array [1 .. operandStkSize] of integer;

        { The value field can contain either an data value (e.g. manifest value or 
          variable address) or a pointer to the head of a shunt (true branch) list from 
          a Boolean expression. }
        operandStkValue: array [1 .. operandStkSize] of integer;

        { The regnum field contains the register number of a temporary register if any }
        operandStkRegnum: array [1 .. operandStkSize] of integer;

        { The length field can contain either a symbol length (e.g. byte or word) 
          or a pointer to the head of a false branch list from a Boolean expression. }
        operandStkLength: array [1 .. operandStkSize] of integer;

        operandStkTop: 0 .. operandStkSize;

        { The Array Table contains bounds for manifest subscript checking }
        arrayDscrAddr:  array [1 .. maxArrayBounds] of integer;
        arrayLowers:    array [1 .. maxArrayBounds] of integer;
        arrayUppers:    array [1 .. maxArrayBounds] of integer;
        arrayBoundsTop: 0 .. maxArrayBounds;

        { Fix Address stack }
        fixStack:    array [1 .. fixStackSize] of integer;
        fixStackTop: 0 .. fixStackSize; { initially 0 }

        { Fix label number - used in generating unique branch labels }
        fixLabelNumber: integer;        { initially 0 }

        { Shunt list elements, used in converting Boolean expressions to control flow.  
          An element consists of 2 fields: a link to the next element in the list and 
          a code area address.  The address field points to a forward branch instruction 
          which must have its target filled in. }
        shuntFreeListHead: ShuntRef;
        shuntAddress: array [1 .. maxShunts] of integer;
        shuntLink:    array [1 .. maxShunts] of ShuntRef;

        { Case Stack - contains label-address pairs for all (nested) case statements 
          currently being processed. }
        caseStackTop:   0 .. caseStackSize;
        caseTCodeAddr:  array [1 .. caseStackSize] of integer;

        { Address (offset) of the last tcode instruction to be read from the tcode file }
        tCodeAddress: integer;          { initially 1 }
        nextTCodeAddress: integer;      { initially 1 }

        { The size of the data area is read from the tcode file and written to the object file. }
        dataAreaSize: integer;

        { misc. }
        tab: char;
        backslash: char;
        newline: char;
        carriagereturn: char;

        { UNIX argument file identifiers, for gpc compatibility }
        {==
        NcoderSsl, NtCode, Nobject, Noptions: array [1 .. 50] of char;
        ==}


    procedure Assert (assertion: Boolean; number: integer);
        { Procedure to implement programmer assertion checking with identification numbers. }
        begin
            if not assertion then
                begin
                    write ('### Coder assertion ', number: 1, ' failed: ');

                    case number of
                        assert1:
                            ; { Unused }
                        assert2:
                            write ('jump condition is iJalways or iJnever in oOperandComplementJumpCondition');
                        assert3:
                            ; { Unused }
                        assert4:
                            write ('coder read past end of tCode generated by semantic phase');
                        assert5:
                            write ('compound token string literal length less than one');
                        assert6:
                            write ('less than two operands in operand stack in oOperandMultiplyManifestValues');
                        assert7:
                            write ('internal error in coder.pt (report to maintainer)');
                        assert8, assert9:
                            ; { Problem message already reported }
                        assert10:
                            write ('empty fix stack in oFixPopAddress');
                        assert11:
                            write ('less than two operands in operand stack in oOperandAddManifestValues');
                        assert12:
                            write ('less than two operands in operand stack in oOperandSubtractManifestValues');
                        assert13:
                            write ('empty operand stack in oOperandPop');
                        assert14:
                            ; { Unused }
                        assert15:
                            write ('less than two operands in operand stack in ooOperandCompareLeftAndRight');
                        assert16:
                            write ('less than three operands in operand stack in oOperandCompareRightAndDest');
                        assert17:
                            write ('compound token tCode is not tLiteralAddress in oOperandPushVariable');
                        assert18:
                            write ('compound token tCode is not tLiteralInteger in oOperandPushInteger');
                        assert19:
                            write ('compound token tCode is not tLiteralChar in oOperandPushChar');
                        assert20:
                            write ('compound token tCode is not tLiteralBoolean in oOperandPushBoolean');
                        assert21:
                            ; { Unused }
                        assert22:
                            write ('compound token tCode is not tTrap in oOperandPushTrap');
                        assert23:
                            write ('sslTableSize too small (increase in coder.pt)');
                        assert25:
                            write ('coder phase ended without consuming all of tCode token stream');
                        assert26:
                            write ('compound token tCode is not tStringData in oEmitString');
                        assert27:
                            write ('compound token tCode is not tCallEnd in oOperandPushProcedure');
                        assert28:
                            write ('compound token tCode is not tLiteralString in oOperandPushStringAddress');
                        assert29:
                            write ('less than two operands in operand stack in oOperandFoldManifestSubscript');
                        assert30:
                            write ('top operand not manifest in oOperandFoldManifestSubscript');
                        assert31:
                            write ('subscripted operand not an array in oOperandFoldManifestSubscript');
                        assert33:
                            write ('jump condition is iJnever in oEmitConditionalForwardBranch');
                        assert34:
                            ; { Unused }
                        assert35:
                            write ('jump condition is iJnever in oEmitConditionalBackwardBranch');
                        assert36:
                            write ('empty case stack in oCasePop');
                        assert37:
                            ; { Unused }
                        assert38:
                            write ('less than two operands in operand stack in oEmitDouble');
                        assert39, assert40, assert41, assert42, assert43, assert44:
                            ; { Unused }
                        assert45:
                            write ('operand stack not empty at end of coder phase');
                        assert46:
                            write ('fix stack not empty at end of coder phase');
                        assert47:
                            write ('case stack not empty at end of coder phase');
                        assert48:
                            ; { Unused }
                        assert49:
                            write ('empty operand stack in oOperandPushArrayLowerBound');
                        assert50:
                            write ('subscripted operand is not a static array in oOperandPushArrayLowerBound');
                        assert51:
                            write ('subscripted operand not an array in oOperandPushArrayLowerBound');
                        assert52:
                            write ('no free registers in oTempAllocate');
                        assert53:
                            write ('no allocated register in oTempFree');
                    end;

		    write ('while processing line ', lineNumber);
		    writeln;
                    writeln;

                    processing := false;
                    abort := true;
                end;
        end { Assert };


    procedure SubscriptError (subscript: integer; lowerBound: integer; upperBound: integer);
        { Report a manifest subscript out of bounds. }
        begin
            write ('line ', lineNumber: 1, ': subscript [', subscript: 1, '] out of bounds [',
                  lowerBound: 1, ' .. ', upperBound: 1, ']');
            writeln;
            noErrors := noErrors + 1;
        end { SubscriptError };

    procedure Error (errorCode: ErrorCodes);
        { Report an error and abort processing if the error was fatal. }
        begin
            write ('coder error, line ', lineNumber:1, ': ');
            if errorCode > firstFatalErrorCode then
                write ('program too complicated ');
            case errorCode of
                eDivisionByZero: write ('division by zero');
                eOperandStkOvfl: write (' (operand stack)');
                eFixStackOvfl: write (' (fix address stack)');
                eSslStackOvfl: write (' (SSL stack)');
                eProcAddrTableOvfl: write (' (procedure table)');
                eCaseLimitExceeded: write (' (case stack)');
                eArrayBoundsOvfl: write (' (array table)');
                eCaseStackOvfl: write (' (case stack)');
                eShuntListExhausted: write (' (shunt free list)');
            end;
            writeln;
            noErrors := noErrors + 1;
            if errorCode >= firstFatalErrorCode then
                begin
                    processing := false;        { terminate coding }
                    abort := true;
                end;
        end { Error };

    procedure Initialize;                               
        { Set the compiler options from the options file, read in the S/SL table 
          corresponding to coder.ssl, initialize the coder semantic mechanisms. }

        var
            i: integer;
            c: char;

        begin
            { UNIX argument file identifiers, for gpc compatibility }
            {==
            argv (1, NcoderSsl);
            argv (2, NtCode);
            argv (3, Nobject);
            argv (4, Noptions);
            ==}

            { Initialize special character values }
            tab := chr(9);              { ASCII TAB }
            backslash := chr(92);       { ASCII \ }
            newline := chr(10);         { ASCII NL / LF }
            carriagereturn := chr(13);  { ASCII CR }

            { Trace Execution if Required }
            tracing := false;
            lineNumbering := true;
            checking := true;
            reset (options {==, Noptions==} );

            while not eof (options) do
                begin
                    read (options, c);
                    if c = 't' then
                        begin
                            read (options, c);
                            if (c = '4') then
                                tracing := true
                        end
                    else if c = 'l' then
                        lineNumbering := false
                    else if c = 'k' then
                        checking := false
                    else if c = 'O' then
                        begin
                            checking := false;
                            lineNumbering := false;
                        end;
                end;

            { Initialize the coder ssl table }
            reset (coderSsl {==, NcoderSsl==} );
            i := 0;
            while not eof (coderSsl) do
                begin
                    if i > sslTableSize then
                        Assert (false, assert23);
                    read (coderSsl, sslTable[i]);
                    i := i + 1
                end;

            { Initialize Input/Output }
            rewrite (object {==, Nobject==} );
            reset (tCode {==, NtCode==} );

            { Provide a dummy (non-compound) lookahead token for the first call to 
              AcceptInputToken }
            nextInputToken := tParmEnd;
            nextLineNumber := 1;

            { Initialize semantic mechanisms }
            { Set up the Shunt free list.  Assumes that shunt list is non-null. }
            shuntFreeListHead := 1;
            i := 1;
            while i < maxShunts do
                begin
                    shuntLink[i] := i + 1;
                    i := i + 1
                end;
            shuntLink[i] := undefined;
            i := firstTempReg;
            while i <= lastTempReg do
                begin
                    tempregfree[i] := true;
                    i := i + 1;
                end;
            operandStkTop := 0;
            fixStackTop := 0;
            fixLabelNumber := 0;
            caseStackTop := 0;
            tCodeAddress := 1;
            nextTCodeAddress := 1;

            { Discard the error count word, the ptc command file has already
              checked it and aborted compilation if semantic errors were found.}
            read (tCode, i);

            read (tCode, dataAreaSize);
            { Round the data area size up to a word (VAX 4 byte) boundary }
            dataAreaSize := dataAreaSize + dataAreaSize mod wordSize;

            read (tCode, i);    { tCode size }
        end { Initialize };


{ Procedures to implement the Coder semantic mechanisms. }


    procedure ReverseSense (var branchop: integer);     
        { Invert the parameter jump condition (e.g. bge => blt). }
        { The opcode is assumed to in the SSL encoding. }
        begin
            Assert ( (branchop >= iJalways) and (branchop <= iJnever), assert2);
            if branchop div 2 * 2 = branchop then
                branchop := branchop + 1
            else
                branchop := branchop - 1;
            { handle special case of unconditional jumps }
            if branchop = -10 then
                branchop := 0
            else if branchop = 1 then
                branchop := -9
        end { ReverseSense };

    procedure AllocateShunt (var newShunt: ShuntRef);
        { Allocate a shunt descriptor from the shunt descriptor free list }
        begin
            if shuntFreeListHead <> undefined then
                begin
                    newShunt := shuntFreeListHead;
                    shuntFreeListHead := shuntLink[shuntFreeListHead]
                end
            else
                Error (eShuntListExhausted);
        end { AllocateShunt };

    procedure FreeShuntList (next: ShuntRef);
        { Return the list of shunt descriptors headed by the parameter descriptor 
          to the shunt descriptor free list. }
        var
            current: ShuntRef;

        begin
            while next <> undefined do
                begin
                    current := next;
                    next := shuntLink[current];
                    shuntLink[current] := shuntFreeListHead;
                    shuntFreeListHead := current
                end
        end { FreeShuntList };


    { Emit Mechanism procedures }

    procedure EmitX86Label (labelChar: char; labelNumber: integer);
        { Emit an x86  assembly code label }
        begin
            write (object, labelChar, labelNumber: 1, ':');
        end { EmitX86Label };

    procedure EmitX86StringLiteral;
        { Emit an x86 assembly code string constant }
        var
            i:  1 .. maxLiteralLength;
        begin
            Assert ( (compoundToken = tStringData), assert26);
            write (object, '    .asciz  "');

            i := 1;
            while i <= compoundTokenLength do
                begin
                    if (compoundTokenText[i] = ord('"')) or
                            (compoundTokenText[i] = ord(backslash)) then
                        begin
                            write (object, backslash);
                            write (object, chr (compoundTokenText[i]));
                        end
                    else if compoundTokenText[i] = ord(tab) then
                        write (object, backslash,'t')
                    else if compoundTokenText[i] = ord(newline) then
                        write (object, backslash, 'n')
                    else if compoundTokenText[i] = ord(carriagereturn) then
                        write (object, backslash,'r')
                    else
                        write (object, chr (compoundTokenText[i]));
                    i := i + 1
                end;

            write (object, '"');
            writeln (object);
        end { EmitX86StringLiteral };

    procedure EmitX86Code (opcode: integer; byte: Boolean);
        { Emit the x86 assembly notation for 'opcode' to the object file }
        begin
            lastOpcode := opcode;

            write (object, '    ');

            case opcode of
                iJalways:
                    write (object, 'jmp');
                iJhi:
                    write (object, 'ja');
                iJlos:
                    write (object, 'jbe');
                iJge:
                    write (object, 'jge');
                iJlt:
                    write (object, 'jl');
                iJle:
                    write (object, 'jle');
                iJgt:
                    write (object, 'jg');
                iJne:
                    write (object, 'jne');
                iJeq:
                    write (object, 'je');
                iJnever:
                    Assert (false, assert46);
                iGlobl:
                    write (object, '.globl');
                iCall:
                    write (object, 'call');
                iReturn:
                    write (object, 'ret');
                iEnter:
                    begin
                        write (object, 'pushl   %ebp'); writeln (object);
                        write (object, '        movl    %esp, %ebp');
                    end;
                iLeave:
                    write (object, 'leave');
                iJmp:
                    write (object, 'jmp');
                iText:
                    write (object, '.text');
                iData:
                    write (object, '.data');
                iWord:
                    write (object, '.long');
                iSpace:
                    write (object, '.comm');
                iAdd:
                    write (object, 'addl');
                iInc:
                    write (object, 'incl');
                iDec:
                    write (object, 'decl');
                iSub:
                    write (object, 'subl');
                iMul:
                    write (object, 'imull');
                iDiv:
                    write (object, 'idivl');
                iPush:
                    write (object, 'pushl');
                iPop:
                    write (object, 'popl');
                iShl:
                    write (object, 'shl');
                iExtend:
                    write (object, 'sarl        $31,');
                iLoada:
                    write (object, 'lea');

                { Multi-sized Opcodes }

                iCmp, iMov, iNeg :
                    begin
                        case opcode of
                            iCmp:
                                write (object, 'cmp');
                            iMov:
                                write (object, 'mov');
                            iNeg:
                                write (object, 'neg');
                        end { case };

                        if byte then
                            write (object, 'b')
                        else
                            write (object, 'l');
                    end;
            end { case };

            write (object, '    ');
        end;  { EmitX86Code }

    procedure WriteTempReg (regnum: integer; length: integer);
    begin
        { We use registers ax, bx, cx, dx on the x86 }
        begin
            case regnum of
                1: if length = byte then write (object, '%al') else write (object, '%eax');
                2: if length = byte then write (object, '%bl') else write (object, '%ebx');
                3: if length = byte then write (object, '%cl') else write (object, '%ecx');
                4: if length = byte then write (object, '%dl') else write (object, '%edx');
            end;
        end;
    end { WriteTempReg };

    procedure EmitX86Mode (mode: integer; offset: integer; regnum: integer;
                length: integer);
        { Emit the x86 assembly notation for 'mode' with 'offset'
          to the object file }
        var i: integer;
            iend: integer;
        begin
            case mode of
                mStatic:        
                    if offset < 0 then
                        { string constant data in code area }
                        write (object, 's', -offset: 1)
                    else
                        write (object, 'u+', offset: 1);
                mStaticManifest:        
                    write (object, '$u+', offset: 1);
                mTemp:  
                    WriteTempReg (regnum, length);
                mTempIndirect:  
                    if lastOpcode = iJmp then
                        begin
                            { special notation for this instruction }
                            write (object, '*');
                            WriteTempReg (regnum, length);
                        end
                    else
                        begin
                            if offset <> 0 then
                                write (object, offset: 1);
                            write (object, '(');
                            WriteTempReg (regnum, word);
                            write (object, ')');
                        end;
                mTempIndirectCaseOffset:        
                    begin
                        write (object, 'c', offset: 1);
                        write (object, '(');
                        WriteTempReg (regnum, word);
                        write (object, ')');
                    end;
                mStackReg:
                    write (object, '%esp');
                mStack:
                    write (object, '(%esp)');
                mBaseReg:
                    write (object, '%ebp');
                mArgument:
                    write (object, offset: 1, '(%ebp)');
                mManifest:      
                    write (object, '$', offset: 1);
                mLineNum:       
                    write (object, 'n');
                mResultReg:     
                    if length = byte then
                        write (object, '%al')
                    else
                        write (object, '%eax');
                mRemainderReg:  
                    if length = byte then
                        write (object, '%dl')
                    else
                        write (object, '%edx');
                mScratchReg1:
                    write (object, '%esi');
                mScratchReg2:
                    write (object, '%edi');
                mGlobalBase:
                    write (object, 'u');
                mMainProc:
                    write (object, 'ptmain');
                mProc:
                    write (object, 'p', offset: 1);
                mTrap:  
                    write (object, 'pttrap', offset: 1);
                mWord:
                    write (object, offset: 1);
            end { case };
        end;  { EmitX86Mode }

    procedure EmitX86SrcMode (mode: integer; offset: integer; 
                regnum: integer; length: integer);
        begin
            EmitX86Mode (mode, offset, regnum, length);
            write (object, ',');
        end { EmitX86SrcMode };

    procedure EmitX86DstMode (mode: integer; offset: integer; 
                regnum: integer; length: integer);
        begin
            EmitX86Mode (mode, offset, regnum, length);
            writeln (object);
        end { EmitX86DstMode };

    procedure EmitX86DstLabel (labelChar: char; labelNumber: integer);
        { Emit an x86 assembly code label as destination operand }
        begin
            write (object, labelChar, labelNumber: 1);
            writeln (object);
        end { EmitX86DstLabel };

    procedure EmitX86None;
        begin
            writeln (object);
        end { EmitX86None };

    procedure EmitDouble (opCode: integer);
        { Emit a double operand instruction with the parameter opcode, the source operand 
          addressing mode of the top operand stack entry and the destination operand 
          addressing mode of the second from top operand stack entry.  If an addressing mode 
          requires an associated manifest value (e.g. addressing mode is Index)
          take that value from the value field of the addressing mode's operand stack entry. }
        var
            sourceMode:   integer;
            sourceOffset: integer;
            sourceRegnum: integer;
            sourceLength: integer;
            destMode:     integer;
            destOffset:   integer;
            destRegnum:   integer;
            destLength:   integer;
            byteFlag:     Boolean;      

        begin
            Assert ( (operandStkTop >= 2), assert38);
            byteFlag := false;

            if operandStkLength[operandStkTop] = byte then
                byteFlag := true;

            EmitX86Code (opCode, byteFlag);

            sourceMode := operandStkKind[operandStkTop];
            sourceOffset := operandStkValue[operandStkTop];
            sourceRegnum := operandStkRegnum[operandStkTop];
            sourceLength := operandStkLength[operandStkTop];

            EmitX86SrcMode (sourceMode, sourceOffset, sourceRegnum, sourceLength);

            destMode := operandStkKind[operandStkTop-1];
            destOffset := operandStkValue[operandStkTop-1];
            destRegnum := operandStkRegnum[operandStkTop-1];
            destLength := operandStkLength[operandStkTop-1];

            EmitX86DstMode (destMode, destOffset, destRegnum, destLength);
        end { EmitDouble };

    procedure EmitSingle (opCode: integer);
        { Emit a single operand instruction with the parameter opcode and the addressing mode 
          of the top operand stack entry.  If the adressing mode requires an associated 
          manifest value (e.g. addressing mode is Index) that value is taken from the
          top operand stack entry's value field. }
        var
            mode:     integer;
            offset:   integer;
            regnum:   integer;
            length:   integer;
            byteFlag: Boolean;  

        begin
            byteFlag := false;

            if operandStkLength[operandStkTop] = byte then
                byteFlag := true;

            EmitX86Code (opCode, byteFlag);

            mode := operandStkKind[operandStkTop];
            offset := operandStkValue[operandStkTop];
            regnum := operandStkRegnum[operandStkTop];
            length := operandStkLength[operandStkTop];

            EmitX86DstMode (mode, offset, regnum, length);
        end { EmitSingle };

    procedure EmitNone (opCode: integer);
        { Emit a zero-operand instruction }
        begin
            EmitX86Code (opCode, false);
            EmitX86None;
        end { EmitNone };

    procedure EmitProcLabel (mode: integer);
        { Emit the label for a procedure }
        begin
            if mode = mMainProc then
                write (object, 'ptmain:')
            else if mode = mLineNum then
                write (object, 'n:')
            else
                EmitX86Label ('p', tCodeAddress)
        end { EmitProcLabel };

    procedure EmitString;
        { Emit the text associated with the last tLiteralString token accepted 
          (packed one character per byte). }
        begin
            Assert ( (compoundToken = tStringData), assert26);
            { The string's T-code address is used as its label }
            EmitX86Label ('s', tCodeAddress);
            EmitX86StringLiteral;
        end { EmitString };

    procedure EmitForwardBranch (branchOperation: integer; labelNumber: integer);
        { Emit a forward branch instruction with the 
          parameter branch operation and label. }
        begin
            EmitX86Code (branchOperation, false);
            EmitX86DstLabel ('f', labelNumber);
        end { EmitForwardBranch };

    procedure EmitUnconditionalForwardBranch;
        begin
            EmitForwardBranch (iJalways, fixLabelNumber + 1);
        end { EmitUnconditionalForwardBranch };

    procedure EmitConditionalForwardBranch;
        var
            branchOperation: integer;
        begin
            branchOperation := operandStkKind[operandStkTop];
            Assert ( (branchOperation <> iJnever), assert33);
            EmitForwardBranch (branchOperation, fixLabelNumber + 1);
        end { EmitConditionalForwardBranch };

    procedure EmitBackwardBranch (branchOperation: integer; labelNumber: integer);
        { Emit a backward branch instruction with the parameter branch operation and label. }
        begin
            EmitX86Code (branchOperation, false);
            EmitX86DstLabel ('b', labelNumber);
        end { EmitBackwardBranch };

    procedure EmitUnconditionalBackwardBranch;
        { Emit an unconditional backward branch instruction whose target
          label is the top fix address stack entry. }
        begin
            EmitBackwardBranch (iJalways, fixStack[fixStackTop]);
        end { EmitUnconditionalBackwardBranch };

    procedure EmitConditionalBackwardBranch;
        { Emit a conditional backward branch instruction with the branch condition 
          of the top operand and with the top address fix stack entry as its target label. }
        var
            branchOperation:    integer;
        begin
            branchOperation := operandStkKind[operandStkTop];
            Assert ( (branchOperation <> iJnever), assert35);
            EmitBackwardBranch (branchOperation, fixStack[fixStackTop]);
        end { EmitConditionalBackwardBranch };

    procedure EmitCaseBranchTable;
        { Emit a table of case alternative addresses.  
          The table is constructed from the case branch table in the tcode stream 
          using the tcode address of each alternative as a label tag for the 
          alternative's code. }
        var
            i: integer;
            tCodeLoc: integer;
        begin
            i := 1;     { tCode case table index }
            EmitNone (iData);
            EmitX86Label ('c', caseTCodeAddr[caseStackTop]);
            repeat
                tCodeLoc := tCodeCaseTable[i];
                EmitX86Code (iWord, false);

                if tCodeLoc > 0 then
                    { Alternative exists }
                    EmitX86DstLabel ('v', tCodeLoc)
                else
                    { No alternative for this value - use case abort label }
                    EmitX86DstLabel ('a', caseTCodeAddr[caseStackTop]);
                i := i + 1
            until i > caseHigh - caseLow + 1;
            EmitNone (iText);
        end { EmitCaseBranchTable };


{  Fix Address Mechanism procedures }

    procedure FixPushAddress;
        begin
            if fixStackTop < fixStackSize then
                begin
                    fixStackTop := fixStackTop + 1;
                    fixLabelNumber := fixLabelNumber + 1;
                    { Save the label used for the backward branch }
                    fixStack[fixStackTop] := fixLabelNumber;
                    EmitX86Label ('b', fixLabelNumber);
                end
            else
                Error (eFixStackOvfl);
        end { FixPushAddress };

    procedure FixPushLastAddress;
        { Save the tCode address of a forward branch instruction operand 
          which will be used as the label when the target location becomes known. }
        begin
            if fixStackTop < fixStackSize then
                begin
                    fixStackTop := fixStackTop + 1;
                    fixLabelNumber := fixLabelNumber + 1;
                    { Save the label used for the forward branch }
                    fixStack[fixStackTop] := fixLabelNumber;
                end
            else
                Error (eFixStackOvfl)
        end;

    procedure FixForwardBranch (fromLabel: integer);    
        { Emit the target label of a previously emitted forward branch }
        begin
            EmitX86Label ('f', fromLabel);
        end { FixForwardBranch };

    procedure FixAndFreeShuntList;
        { All the elements in the top operand's shunt list (unresolved forward branches) 
          are fixed to have the address of the next instruction to be emitted as their target.  
          The fixed shunt list elements are returned to the shunt free list. }
        var
            current: ShuntRef;
        begin
            current := operandStkValue[operandStkTop];
            { Shunts must be processed in LIFO order. }
            while current <> undefined do
                begin
                    FixForwardBranch (shuntAddress[current]);
                    current := shuntLink[current]
                end;
            FreeShuntList (operandStkValue[operandStkTop]);
        end { FixAndFreeShuntList };

    procedure FixAndFreeFalseBranches;
        { This performs the same function as FixAndFreeShuntList on the top operand's 
          false branch list.  It also clears the top operand's jump condition and 
          false branch fields. }
        var
            current:            ShuntRef;
        begin
            current := operandStkLength[operandStkTop];
            { Addressess must be processed in LIFO order. }
            while current <> undefined do
                begin
                    FixForwardBranch (shuntAddress[current]);
                    current := shuntLink[current]
                end;
            FreeShuntList (operandStkLength[operandStkTop]);
            operandStkKind[operandStkTop] := undefined;
            operandStkLength[operandStkTop] := undefined
        end { FixAndFreeFalseBranches };


{  Temporary Register Mechanism procedures }

    procedure TempAllocate;
        var i: integer;
        begin
            tempregnum := undefined;
            i := firstTempReg;
            while ((i <= lastTempReg) and (tempregnum = undefined)) do
                begin
                    if tempregfree [i] then 
                        tempregnum := i;
                    i := i + 1
                end;
            Assert (tempregnum <> undefined, assert52);
            tempregfree[tempregnum] := false;
        end;
        
    procedure TempFree;
        begin
            Assert (tempregnum <> undefined, assert53);
            tempregfree[tempregnum] := true;
        end;

    procedure AssertTempsAreAllFree;
        var i: integer;
        begin
            i := firstTempReg;
            while (i <= lastTempReg) do
                begin
                    if tempregfree [i] then
                    else
                    begin
                        write ('Line ', lineNumber);
                        write (' temp reg not free: ');
                        write (i);
                        write (' ');

                        case i of
                            1: write ('%eax');
                            2: write ('%ebx');
                            3: write ('%ecx');
                            4: write ('%edx');
                        end;

                        writeln;
                    end;
                    i := i + 1
                end;
        end;


{  Operand Stack Mechanism procedures }

    procedure OperandPush (kind: integer; value: integer; regnum: integer; length: integer);
        { Push an operand stack entry with the parameter attributes }
        begin
            if operandStkTop < operandStkSize then
                begin
                    operandStkTop := operandStkTop + 1;
                    operandStkKind[operandStkTop] := kind;
                    operandStkValue[operandStkTop] := value; 
                    operandStkRegnum[operandStkTop] := regnum; 
                    operandStkLength[operandStkTop] := length
                end
            else
                Error (eOperandStkOvfl);
        end { OperandPush };

    procedure OperandPushProcedure;
        { Push an operand stack entry for the procedure referenced in the tCallEnd tcode 
          just accepted.  }
        begin
            Assert (compoundToken = tCallEnd, assert27);
            OperandPush (mProc, compoundTokenValue, undefined, word);
        end { OperandPushProcedure };

    procedure OperandPushStringAddress;
        { Push an operand stack entry for the string's address }
        begin
            Assert ( (compoundToken = tLiteralString), assert28);
            OperandPush (mStatic, compoundTokenValue, undefined, word);
        end { OperandPushStringAddress };

    procedure OperandPushArrayLowerBound;
        { Push and operand stack entry which is the manifest value of
          the lower bound of the array which is the current top operand. }
        var
            descriptorAddress: integer;
            lowerBound: integer;
            i: integer;
        begin
            Assert ( (operandStkTop >= 1), assert49);
            Assert ( (operandStkKind[operandStkTop] = mStatic), assert50);
            descriptorAddress := operandStkValue[operandStkTop];
            i := 0;
            { Locate the array's array table entry and copy its lower bound field. }
            while i < arrayBoundsTop do
                begin
                    i := i + 1;
                    if descriptorAddress = arrayDscrAddr[i] then
                        begin
                            lowerBound := arrayLowers[i];
                            i := arrayBoundsTop + 1;
                        end
                end;
            { The array must be found in the array table }
            Assert ( (i = arrayBoundsTop+1), assert51);

            { Push the lower bound }
            OperandPush (mManifest, lowerBound, undefined, word);
        end { OperandPushArrayLowerBound };

    procedure OperandPushArrayUpperBound;
        { Push and operand stack entry which is the manifest value of
          the upper bound of the array which is the current top operand. }
        var
            descriptorAddress: integer;
            upperBound: integer;
            i: integer;
        begin
            Assert ( (operandStkTop >= 1), assert49);
            Assert ( (operandStkKind[operandStkTop] = mStatic), assert50);
            descriptorAddress := operandStkValue[operandStkTop];
            i := 0;
            { Locate the array's array table entry and copy its upper bound field. }
            while i < arrayBoundsTop do
                begin
                    i := i + 1;
                    if descriptorAddress = arrayDscrAddr[i] then
                        begin
                            upperBound := arrayUppers[i];
                            i := arrayBoundsTop + 1;
                        end
                end;
            { The array must be found in the array table }
            Assert ( (i = arrayBoundsTop+1), assert51);

            { Push the upper bound }
            OperandPush (mManifest, upperBound, undefined, word);
        end { OperandPushArrayUpperBound };

    procedure OperandComplementJumpCondition;
        { Complement the top operand's jump condition and exchange its shunt (true branch) 
          list and false branch list fields, since true branches become false branches 
          (and vice versa) when the condition field is inverted. }
        var
            temp: integer;
        begin
            ReverseSense (operandStkKind[operandStkTop]);
            temp := operandStkValue[operandStkTop];
            operandStkValue[operandStkTop] := operandStkLength[operandStkTop];
            operandStkLength[operandStkTop] := temp
        end { OperandComplementJumpCondition };

    procedure OperandMergeShuntsWithAddress;
        { The top fix stack address, which is the address of an unresolved
          forward branch instruction, is added to the top operand's shunt list. }
        var
            newShunt:   ShuntRef;
        begin
            AllocateShunt (newShunt);
            shuntAddress[newShunt] := fixStack[fixStackTop];
            shuntLink[newShunt] := operandStkValue[operandStkTop];
            operandStkValue[operandStkTop] := newShunt
        end { OperandMergeShuntsWithAddress };

    procedure OperandMergeShunts;
        { Merge the shunt lists of the top 2 operands.  The lists are merged in LIFO order 
          (i.e. the first shunt of the second operand is linked to the last shunt of 
          the top operand). }
        var
            current:  ShuntRef;
            previous: ShuntRef;
        begin
            current := operandStkValue[operandStkTop];
            previous := undefined;
            { Locate the end of the top operand's shunt list. }
            while current <> undefined do
                begin
                    previous := current;
                    current := shuntLink[current]
                end;
            if previous = undefined then
                { The top operand has no shunt list. }
                operandStkValue[operandStkTop] := operandStkValue[operandStkTop - 1]
            else
                { Concatenate lists in LIFO order. }
                shuntLink[previous] := operandStkValue[operandStkTop-1]
        end { OperandMergeShunts };

    procedure OperandCompare (first: OperandStkRef; second: OperandStkRef);
        { Set the S/SL result value to yes if the top 2 operands are identical, 
          otherwise set it to no. }
        begin
            if (operandStkKind[first] = operandStkKind[second]) and
                   (operandStkKind[first] <> mTemp) and
                   (operandStkKind[first] <> mTempIndirect) and
                   (operandStkValue[first] = operandStkValue[second]) and
                   (operandStkRegnum[first] = operandStkRegnum[second]) and
                   (operandStkLength[first] = operandStkLength[second]) then
                resultValue := yes
            else
                resultValue := no;
        end { OperandCompare };

    procedure OperandCopy (src: OperandStkRef; dst: OperandStkRef);
        { Copy the source operand to the destination operand. }
        begin
            operandStkKind[dst] := operandStkKind[src];
            operandStkValue[dst] := operandStkValue[src];
            operandStkRegnum[dst] := operandStkRegnum[src];
            operandStkLength[dst] := operandStkLength[src];
        end { OperandCopy };

    procedure OperandSwap;
        { Reverse the positions of the top 2 operand stack entries. }
        begin
            if operandStkTop < operandStkSize then
                begin
                    OperandCopy (operandStkTop, operandStkTop+1);
                    OperandCopy (operandStkTop-1, operandStkTop);
                    OperandCopy (operandStkTop+1, operandStkTop-1);
                end
            else
                Error (eOperandStkOvfl);
        end { OperandSwap };

    procedure OperandSwapRightAndDest;
        { Reverse the positions of the top and third operand stack entries. }
        begin
            if operandStkTop < operandStkSize then
                begin
                    OperandCopy (operandStkTop, operandStkTop+1);
                    OperandCopy (operandStkTop-2, operandStkTop);
                    OperandCopy (operandStkTop+1, operandStkTop-2);
                end
            else
                Error (eOperandStkOvfl);
        end { OperandSwapRightAndDest };

    procedure OperandSwapLeftAndDest;
        { Reverse the positions of the second and third operand stack entries. }
        begin
            if operandStkTop < operandStkSize then
                begin
                    OperandCopy (operandStkTop-1, operandStkTop+1);
                    OperandCopy (operandStkTop-2, operandStkTop-1);
                    OperandCopy (operandStkTop+1, operandStkTop-2);
                end
            else
                Error (eOperandStkOvfl);
        end { OperandSwapLeftAndDest };

    procedure OperandPop;
        begin
            Assert ( (operandStkTop >= 1), assert13);
            operandStkTop := operandStkTop - 1
        end { OperandPop };

    procedure OperandFoldManifestSubscript;
        { Fold a manifest subscripting operation, replacing the array operand 
          with a simple variable operand.  Check that the subscript is within the array bounds.  
          The top operand is the manifest subscript,  the second operand is the array variable.
          The array's bounds are retrieved from the array table for the subscript range check 
          and calculation of the subscripted variable's address. }
        var
            descriptorAddress: integer;
            subscript:  integer;
            upperBound: integer;
            lowerBound: integer;

        begin
            Assert ( (operandStkTop >= 2), assert29);
            Assert ( (operandStkKind[operandStkTop] = mManifest) and
                   (operandStkKind[operandStkTop-1] = mStatic), assert30);
            subscript := operandStkValue[operandStkTop];
            descriptorAddress := operandStkValue[operandStkTop-1];
            i := 0;
            { Locate the array's array table entry and copy its lower and upper bound fields. }
            while i < arrayBoundsTop do
                begin
                    i := i + 1;
                    if descriptorAddress = arrayDscrAddr[i] then
                        begin
                            lowerBound := arrayLowers[i];
                            upperBound := arrayUppers[i];
                            i := arrayBoundsTop + 1;
                        end
                end;
            { The array must be found in the array table }
            Assert ( (i = arrayBoundsTop+1), assert31);
            if (subscript  < lowerBound) or (subscript  > upperBound) then
                SubscriptError (subscript, lowerBound, upperBound)
            else
                begin
                    subscript := subscript - lowerBound;
                    if operandStkLength[operandStkTop-1] = word then
                        { Convert a byte offset to a word offset }
                        subscript := subscript * wordSize;
                    { Set the subscripted varable's address.  Note that the array variable's 
                      address points to the base of a 2 word descriptor (lower, upper bound). }
                    operandStkValue[operandStkTop-1] := 
                        operandStkValue[operandStkTop-1] +
                        subscript + 2 * wordSize;  { size of 2 word descriptor }
                end;
        end { OperandFoldManifestSubscript };

    procedure OptionallyEmitSourceCoordinate;
        { If the source coordinate has changed since the last source coordinate update instruction 
          was emitted and line numbering is turned on, emit another update instruction.
          Use an increment (1 word) instruction where possible, otherwise use a move (2 word) 
          instruction. }
        begin
            if lineNumbering and (lineNumber <> lastEmittedLineNumber) then
                begin
                    OperandPush (mLineNum, undefined, undefined, word);
                    if lineNumber = lastEmittedLineNumber + 1 then
                        begin
                            EmitSingle (iInc);
                        end
                    else
                        begin
                            OperandPush (mManifest, lineNumber, undefined, word);
                            EmitDouble (iMov);
                            OperandPop
                        end;
                    OperandPop;
                    lastEmittedLineNumber := lineNumber;
                end
        end { OptionallyEmitSourceCoordinate };

    procedure AcceptInputToken;
        { This procedure provides the interface to the previous pass;  
          it is reponsible for handling all input including line number indicators 
          and the values and text associated with input tokens. }
        var
            acceptedToken: InputTokens;
        begin
            Assert (nextInputToken <> tEndOfFile, assert4);

            { Accept Token }
            acceptedToken := nextInputToken;
            tCodeAddress := nextTCodeAddress;

            { If the token is a compound token,
              read its associated value         }
            if (acceptedToken >= firstCompoundTcode) and 
                   (acceptedToken <= lastCompoundTcode) then
                begin
                    compoundToken := acceptedToken;
                    read (tCode, compoundTokenValue);
                    nextTCodeAddress := nextTCodeAddress + 1;

                    case compoundToken of
                        tLiteralAddress, tLiteralInteger, tLiteralChar,
                        tLiteralBoolean, tLiteralString, tSkipString,
                        tWhileTest, tWhileEnd, tRepeatTest, tCallEnd,
                        tLineNumber, tTrap, tIfThen, tIfMerge, tSkipProc,
                        tCaseSelect, tCaseMerge:
                            ;   { Do nothing }
                        tCaseEnd:
                            { Read the lowest and highest label values
                              followed by the case branch table. }
                            begin
                                caseLow := compoundTokenValue;
                                read (tCode, caseHigh);
                                i := 1;
                                repeat
                                    read (tCode, tCodeCaseTable[i]);
                                    i := i + 1;
                                until i > caseHigh - caseLow + 1;
                                nextTCodeAddress := nextTCodeAddress + (caseHigh - caseLow) + 2
                            end;
                        tStringData:
                            begin
                                compoundTokenLength := compoundTokenValue;
                                compoundTokenValue := tCodeAddress;
                                i := 1;
                                while i <= compoundTokenLength do
                                    begin
                                        read (tCode, compoundTokenText[i]);
                                        i := i + 1
                                    end;
                                nextTCodeAddress := nextTCodeAddress + compoundTokenLength;
                            end;
                    end         { case compoundToken }
                end;

            { Update Line Number }
            lineNumber := nextLineNumber;

            { Read Next Input Token }
            repeat
                if eof (tCode) then
                    nextInputToken := tEndOfFile
                else
                    begin
                        read (tCode, nextInputToken);
                        nextTCodeAddress := nextTCodeAddress + 1;
                    end;

                if nextInputToken = tLineNumber then
                    begin
                        { Read the line number value }
                        read (tCode, nextLineNumber);
                        nextTCodeAddress := nextTCodeAddress + 1;
                    end;
            until nextInputToken <> tLineNumber;

            { Trace Input }
            if tracing then
                begin
                    write ('Input token accepted ', acceptedToken: 1,
                        ';  Line ', lineNumber: 1, ';  Next input token ', nextInputToken: 1);
                    writeln;
                end;
        end { AcceptInputToken };

    procedure SslSyntaxError;
        { A syntax error in the semantic token stream implies a compiler failure.  
          Either the semantic analyzer is generating an invalid stream or the coder
          expects an invalid stream. }
        begin
            write ('### Coder S/SL program failure:  syntax error in Tcode token stream');
            writeln;
            write ('    (semantic pass output stream does not match expected input stream)');
            writeln;
            write ('while processing line ', lineNumber);
            writeln;
            Assert(false, assert7);
        end { SslSyntaxError };

    procedure SslTrace;
        begin
            write ('Table index ', sslPointer-1: 1, ';  Operation ', 
                operation: 1, ';  Argument ', sslTable[sslPointer]: 1);
            writeln;
        end { SslTrace };

    procedure SslFailure (failCode: FailureCodes);
        begin
            write ('### Coder S/SL program failure: ');

            case failCode of
                fSemanticChoiceFailed:
                    write ('Semantic choice failed');
                fChoiceRuleFailed:
                    write ('Choice rule returned without a value');
            end;

            writeln;
            write ('while processing line ', lineNumber);
            writeln;
            SslTrace;
            Assert (false, assert8);
        end { SslFailure };

    procedure SslChoice (choiceTag: integer);

    { This procedure performs both input and semantic choices.  It sequentially tests 
      each alternative value against the tag value, and when a match is found, 
      performs a branch to the corresponding alternative path.  If none of the alternative
      values matches the tag value, sslTable interpretation proceeds to the operation 
      immediately following the list of alternatives (normally the otherwise path).  
      The flag choiceTagMatched is set to true if a match is found and false otherwise. }

        var
            numberOfChoices: integer;

        begin
            sslPointer := sslPointer + sslTable[sslPointer];
            numberOfChoices := sslTable[sslPointer];
            sslPointer := sslPointer + 1;
            choiceTagMatched := false;

            repeat
                if sslTable[sslPointer] = choiceTag then
                    begin
                        sslPointer := sslPointer + 1;
                        sslPointer := sslPointer - sslTable[sslPointer];
                        choiceTagMatched := true;
                        numberOfChoices := 0;
                    end
                else
                    begin
                        sslPointer := sslPointer + 2;
                        numberOfChoices := numberOfChoices - 1;
                    end;

            until numberOfChoices = 0;

            if tracing then
                begin
                    write ('Choice tag ', choiceTag : 1);
                    if choiceTagMatched then
                        write (' (matched)')
                    else
                        write (' (not matched)');
                    writeln
                end

        end { SslChoice };

    procedure GenerateCode;
    { Walk the ssl code generator table. }

        begin
            { Initialize Table Walker State }
            processing := true;
            sslPointer := 0;
            sslTop := 0;
            noErrors := 0;
            abort := false;
            AcceptInputToken;

            repeat { until processing = false }

                operation := sslTable[sslPointer];
                sslPointer := sslPointer + 1;

                if tracing then
                    SslTrace;

                case operation of

                    oCall:
                        if sslTop < sslStackSize then
                            { no allowance for long calls }
                            begin
                                sslTop := sslTop + 1;
                                sslStack[sslTop] := sslPointer + 1;
                                sslPointer := sslTable[sslPointer]
                            end
                        else
                            begin
                                Error (eSslStackOvfl);
                                processing := false
                            end;

                    oReturn:
                        if sslTop > 0 then
                            begin
                                sslPointer := sslStack[sslTop];
                                sslTop := sslTop - 1
                            end
                        else
                            processing := false;        { normal return }

                    oRuleEnd:
                        SslFailure (fChoiceRuleFailed);

                    oJumpForward:
                        sslPointer := sslPointer + sslTable[sslPointer];

                    oJumpBack:
                        sslPointer := sslPointer - sslTable[sslPointer];

                    oInput:
                        begin
                            if nextInputToken = sslTable[sslPointer] then
                                AcceptInputToken
                            else
                                SslSyntaxError;
                            sslPointer := sslPointer + 1
                        end;

                    oInputAny:
                        if nextInputToken <> tEndOfFile then
                            AcceptInputToken
                        else
                            { Premature end of file }
                            SslSyntaxError;

                    oInputChoice:
                        begin
                            SslChoice (nextInputToken);
                            if choiceTagMatched then
                                AcceptInputToken
                        end;

                    oEmit:
                        { No emitting operations }
                        Assert (false, assert9);

                    oError:
                        begin
                            Error (sslTable[sslPointer]);
                            sslPointer := sslPointer + 1
                        end;

                    oChoice:
                        SslChoice (resultValue);

                    oChoiceEnd:
                        SslFailure (fSemanticChoiceFailed);

                    oSetParameter:
                        begin
                            parameterValue := sslTable[sslPointer];
                            sslPointer := sslPointer + 1
                        end;

                    oSetResult:
                        begin
                            resultValue := sslTable[sslPointer];
                            sslPointer := sslPointer + 1
                        end;


                    { ****
                      *  *  Fix Address Mechanism Operations
                      **** }

                    oFixPushLastAddress:
                        FixPushLastAddress;

                    oFixPushAddress:
                        FixPushAddress;

                    oFixPopAddress:
                        begin
                            Assert ( (fixStackTop >= 1), assert10);
                            fixStackTop := fixStackTop - 1
                        end;

                    oFixSwapAddresses:
                        if fixStackTop < fixStackSize then
                            begin
                                fixStack[fixStackTop+1] := fixStack[fixStackTop];
                                fixStack[fixStackTop] := fixStack[fixStackTop-1];
                                fixStack[fixStackTop-1] := fixStack[fixStackTop+1];
                            end
                        else
                            Error (eFixStackOvfl);

                    oFixAndFreeShuntList:
                        FixAndFreeShuntList;

                    oFixAndFreeFalseBranches:
                        FixAndFreeFalseBranches;

                    oFixForwardBranch:
                        FixForwardBranch (fixStack[fixStackTop]);



                    { ****
                      *  *  Emit Mechanism Operations
                      **** }

                    oEmitProcLabel:
                        EmitProcLabel (parameterValue);

                    oEmitNone:
                        EmitNone (parameterValue);

                    oEmitSingle:
                        EmitSingle (parameterValue);

                    oEmitDouble:
                        EmitDouble (parameterValue);

                    oEmitString:
                        EmitString;

                    oEmitConditionalForwardBranch:
                        EmitConditionalForwardBranch;

                    oEmitUnconditionalForwardBranch:
                        EmitUnconditionalForwardBranch;

                    oEmitConditionalBackwardBranch:
                        EmitConditionalBackwardBranch;

                    oEmitUnconditionalBackwardBranch:
                        EmitUnconditionalBackwardBranch;

                    oEmitSourceCoordinate:
                        begin
                            OptionallyEmitSourceCoordinate;
                            AssertTempsAreAllFree
                        end;

                    oEmitMergeSourceCoordinate:
                        { The line number value must be explicitly set
                          not changed from the old value (e.g. inc  oldNum) }
                        begin
                            lastEmittedLineNumber := undefined;
                            OptionallyEmitSourceCoordinate;
                            AssertTempsAreAllFree
                        end;

                    oEmitCaseMergeBranch:
                        begin
                            EmitX86Code (iJalways, false);
                            EmitX86DstLabel ('m', caseTCodeAddr[caseStackTop]);
                        end;

                    oEmitCaseBranchTable:
                        EmitCaseBranchTable;


                    { ****
                      *  *  Temporary Mechanism Operations
                      **** }

                    oTempAllocate:
                        TempAllocate;

                    oTempFree:
                        begin
                            tempregnum := operandStkRegnum[operandStkTop];
                            TempFree;
                        end;


                    { ****
                      *  *  Operand Stack Mechanism Operations
                      **** }

                    oOperandPushVariable:
                        { Called after the acceptance of ANY variable token,
                          whether it be of a simple variable or an array. }
                        begin
                            Assert ( (compoundToken = tLiteralAddress), assert17);
                            OperandPush (mStatic, compoundTokenValue, undefined, word);
                        end;

                    oOperandPushInteger:
                        begin
                            Assert ( (compoundToken = tLiteralInteger), assert18);
                            OperandPush (mManifest, compoundTokenValue, undefined, word)
                        end;

                    oOperandPushChar:
                        begin
                            Assert ( (compoundToken = tLiteralChar), assert19);
                            OperandPush (mManifest, compoundTokenValue, undefined, byte)
                        end;

                    oOperandPushBoolean:
                        begin
                            Assert ( (compoundToken = tLiteralBoolean), assert20);
                            OperandPush (mManifest, compoundTokenValue, undefined, byte)
                        end;

                    oOperandPushMode, oOperandPushJumpCondition:
                        OperandPush (parameterValue, undefined, undefined, undefined);

                    oOperandPushTemp:
                        OperandPush (mTemp, undefined, tempregnum, word);

                    oOperandChooseMode, oOperandChooseJumpCondition:
                        resultValue := operandStkKind[operandStkTop];

                    oOperandSetMode:
                        operandStkKind[operandStkTop] := parameterValue;

                    oOperandSetValue:
                        operandStkValue[operandStkTop] := parameterValue;

                    oOperandChooseValue:
                        resultValue := operandStkValue[operandStkTop];

                    oOperandIsValueNegative:
                        if operandStkValue[operandStkTop] < 0 then
                            resultValue := yes
                        else
                            resultValue := no;

                    oOperandSetLength:
                        operandStkLength[operandStkTop] := parameterValue;

                    oOperandSetRegnum:
                        operandStkRegnum[operandStkTop] := parameterValue;

                    oOperandChooseLength:
                        resultValue := operandStkLength[operandStkTop];

                    oOperandPushCaseLow:
                        OperandPush (mManifest, caseLow, undefined, word);

                    oOperandPushCaseHigh:
                        OperandPush (mManifest, caseHigh, undefined, word);

                    oOperandPushProcedure:
                        OperandPushProcedure;

                    oOperandPushStringAddress:
                        OperandPushStringAddress;

                    oOperandPushTrap:
                        begin
                            Assert ( (compoundToken = tTrap), assert22);
                            OperandPush (mTrap, compoundTokenValue, undefined, word);
                        end;

                    oOperandPushArrayLowerBound:
                        OperandPushArrayLowerBound;

                    oOperandPushArrayUpperBound:
                        OperandPushArrayUpperBound;

                    oOperandPushCopy:
                        OperandPush (operandStkKind[operandStkTop],
                            operandStkValue[operandStkTop],
                            operandStkRegnum[operandStkTop],
                            operandStkLength[operandStkTop]);

                    oOperandEnterValueFromCaseTableAddress:
                         operandStkValue[operandStkTop] := caseTCodeAddr[caseStackTop];

                    oOperandEnterValueFromCodeAddress:
                         operandStkValue[operandStkTop] := 0; {[ nextLoc; ]}

                    oOperandEnterValueFromDataAreaSize:
                        operandStkValue[operandStkTop] := dataAreaSize;

                    oOperandCompareLeftAndRight:
                        begin
                            Assert ( (operandStkTop >= 2), assert15);
                            OperandCompare (operandStkTop, operandStkTop-1)
                        end;

                    oOperandCompareRightAndDest:
                        begin
                            Assert ( (operandStkTop >= 3), assert16);
                            OperandCompare (operandStkTop, operandStkTop-2)
                        end;

                    oOperandIsJumpCondition:
                        if operandStkKind[operandStkTop] <= lastJumpCode then
                            resultValue := yes
                        else
                            resultValue := no;

                    oOperandComplementJumpCondition:
                        OperandComplementJumpCondition;

                    oOperandAddManifestValues:
                        begin
                            Assert ( (operandStkTop >= 2), assert11);
                            operandStkValue[operandStkTop-1] :=
                                operandStkValue[operandStkTop-1] + operandStkValue[operandStkTop];
                        end;

                    oOperandSubtractManifestValues:
                        begin
                            Assert ( (operandStkTop >= 2), assert12);
                            operandStkValue[operandStkTop-1] :=
                                operandStkValue[operandStkTop-1] - operandStkValue[operandStkTop];
                        end;

                    oOperandMultiplyManifestValues:
                        begin
                            Assert ( (operandStkTop >= 2), assert12);
                            operandStkValue[operandStkTop-1] :=
                                operandStkValue[operandStkTop-1] * operandStkValue[operandStkTop];
                        end;

                    oOperandNegateManifestValue:
                        operandStkValue[operandStkTop] :=
                                -operandStkValue[operandStkTop];

                    oOperandChooseManifestValue:
                        if operandStkKind[operandStkTop] = mManifest then
                            resultValue := operandStkValue[operandStkTop]
                        else
                            resultValue := undefined;

                    oOperandCompareManifestValues:
                        if operandStkValue[operandStkTop] =
                                operandStkValue[operandStkTop-1] then
                            resultValue := yes
                        else
                            resultValue := no;

                    oOperandFoldManifestSubscript:
                        OperandFoldManifestSubscript;

                    oOperandMergeShuntsWithAddress:
                        OperandMergeShuntsWithAddress;

                    oOperandMergeShunts:
                        OperandMergeShunts;

                    oOperandSwap:
                        OperandSwap;

                    oOperandSwapRightAndDest:
                        OperandSwapRightAndDest;

                    oOperandSwapLeftAndDest:
                        OperandSwapLeftAndDest;

                    oOperandPop:
                        OperandPop;


                    { ****
                      *  *  Array Table Mechanism Operations
                      **** }

                    oArrayEnterLowerBound:
                        if arrayBoundsTop < maxArrayBounds then
                            begin
                                arrayBoundsTop := arrayBoundsTop + 1;
                                { Descriptor address is the address of the lower bound. }
                                arrayDscrAddr[arrayBoundsTop] := operandStkValue[operandStkTop-1];
                                arrayLowers[arrayBoundsTop] := operandStkValue[operandStkTop];
                            end
                        else
                            Error (eArrayBoundsOvfl);

                    oArrayEnterUpperBound:
                        arrayUppers[arrayBoundsTop] := operandStkValue[operandStkTop];


                    { ****
                      *  *  Case Mechanism Operations
                      **** }

                    oCasePush:
                        if caseStackTop < caseStackSize then
                            caseStackTop := caseStackTop + 1
                        else
                            Error (eCaseStackOvfl);

                    oCasePop:
                        begin
                            Assert ( (caseStackTop >= 1), assert36);
                            caseStackTop := caseStackTop - 1;
                        end;

                    oCaseEnterTCodeAddress:
                        caseTCodeAddr[caseStackTop] := tCodeAddress;

                    oCaseEnterVariantAddress:
                        EmitX86Label ('v', tCodeAddress);

                    oCaseEnterMergeAddress:
                        EmitX86Label ('m', caseTCodeAddr[caseStackTop]);

                    oCaseEnterAbortAddress:
                        EmitX86Label ('a', caseTCodeAddr[caseStackTop]);


                    { Option Mechanism Operations }

                    oOptionTestChecking:
                        if checking then
                            resultValue := yes
                        else
                            resultValue := no;

                end { case operation };

            until not processing;

            if not abort then
                Assert (eof (tCode), assert25);

        end;    { GenerateCode }


    procedure Finalize;
        begin
            { If the table walker terminated normally check that the state
              of the semantic mechanisms is legal. }
            if not abort then
                { If everything happened legitimately, the temporaries should all be free 
                  and the mechanism stacks should all be empty. }
                begin
                    AssertTempsAreAllFree;
                    Assert (operandStkTop = 0, assert45);
                    Assert (fixStackTop = 0, assert46);
                    Assert (caseStackTop = 0, assert47);
                end;

        end { Finalize };

    begin
        { N.B. We assume here that the invoker of the coder (e.g. the ptc command) 
          has insured that the token stream emitted by the semantic pass is valid 
          (i.e. no semantic errors detected) .  If the stream is illegal the first word 
          will be a positive integer value. }

        Initialize;
        GenerateCode;
        Finalize;
    end.
