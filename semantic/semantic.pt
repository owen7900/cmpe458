{  PT Semantic Analysis Pass Version 5.1

   Date:  30 Jun 1980
          (Revised v5.1 - 8 Feb 2021)

   Author:  Alan Rosselet

   Abstract:
     The semantic analysis pass builds the symbol and type tables.  
     It enforces context sensitive syntax restrictions such as "declaration before use".  
     It performs type checking between assignment L and R values, between expression 
     operands and operators, between formal and actual parameters.  
     It assigns runtime addresses to data objects.  
     It emits a stream of PT pseudo code, tCode, to implement the program.

   Input Files
        semanticSsl:  The S/SL table which drives the program
        parseStream:  Semantic tokens emitted by the parser
        options:      Semantic pass options

   Input Output Files
        temp:  Tcode is emitted to this file as it is generated.  The file
               is read later to back-patch the tCode.

   Output Files
        tCode:   Tcode generated for the source program
        output:  Diagnostic messages.
}


program SemanticAnalysis (output, semanticSsl, parseStream, temp, tCode, options);

    const
        { S/SL Table Walker Operations }
        { Primitive S/SL Table Operations }
        oCall = 0;
        oReturn = 1;
        oRuleEnd = 2;
        oJumpBack = 3;
        oJumpForward = 4;
        oInput = 5;
        oInputAny = 6;
        oInputChoice = 7;
        oEmit = 8;
        oError = 9;
        oChoice = 10;
        oChoiceEnd = 11;
        oSetParameter = 12;
        oSetResult = 13;

{ ===== Pasted contents of semantic.def, generated by S/SL from semantic.ssl -
        defines Semantic Operations, Input/Output Tokens, Error Codes and Semantic Types }

        { Semantic Operations }
        oSymbolTblEnter = 14;
        oSymbolTblUpdate = 15;
        oSymbolTblPushScope = 16;
        oSymbolTblPopScope = 17;
        oSymbolTblPreserveParameters = 18;
        oSymbolTblLookupExternal = 19; { >>14 }
        oSymbolStkPush = 20; { (17) }
        oSymbolStkPushIdentifier = 21;
        oSymbolStkPushLocalIdentifier = 22;
        oSymbolStkPushStandardVariable = 23; { (19) }
        oSymbolStkPushFormalParameter = 24;
        oSymbolStkSetKind = 25; { (17) }
        oSymbolStkEnterValue = 26;
        oSymbolStkEnterStringValue = 27;
        oSymbolStkEnterDataAddress = 28;
        oSymbolStkEnterTypeReference = 29;
        oSymbolStkChooseKind = 30; { >>17 }
        oSymbolStkChooseStandardFile = 31; { >>19 }
        oSymbolStkChooseStandardRoutine = 32; { >>18 }
        oSymbolStkPop = 33;
        oTypeTblEnter = 34;
        oTypeTblUpdate = 35;
        oTypeStkPush = 36; { (20) }
        oTypeStkPushSymbol = 37;
        oTypeStkPushComponent = 38;
        oTypeStkSetKind = 39; { (20) }
        oTypeStkSetRecursionFlag = 40; { (14) }
        oTypeStkChooseRecursionFlag = 41; { >>14 }
        oTypeStkLinkToStandardType = 42; { (16) }
        oTypeStkEnterBounds = 43;
        oTypeStkVerifyBounds = 44; { >>14 }
        oTypeStkEnterParameterCount = 45;
        oTypeStkCompareParameterCount = 46; { >>14 }
        oTypeStkEnterComponentReference = 47;
        oTypeStkChooseKind = 48; { >>20 }
        oTypeStkChooseTypeReference = 49; { >>14 }
        oTypeStkCompareNames = 50; { >>14 }
        oTypeStkSwap = 51;
        oTypeStkPop = 52;
        oEmitNullAddress = 53;
        oEmitValue = 54;
        oEmitString = 55;
        oEmitDataAddress = 56;
        oEmitTrapKind = 57; { (21) }
        oEmitCaseBranchTable = 58;
        oAllocateAlignOnWord = 59;
        oAllocateVariable = 60;
        oAllocateVarParameter = 61;
        oAllocateDescriptor = 62;
        oValuePush = 63; { (13) }
        oValuePushInteger = 64;
        oValuePushChar = 65;
        oValuePushStringLength = 66;
        oValuePushSymbol = 67;
        oValuePushCount = 68;
        oValuePushTypeStkLowerBound = 69;
        oValuePushTypeStkUpperBound = 70;
        oValuePushCodeAddress = 71;
        oValueNegate = 72;
        oValueChoose = 73; { >>13 }
        oValuePop = 74;
        oCasePushDisplay = 75;
        oCasePopDisplay = 76;
        oCaseLookupLabel = 77; { >>14 }
        oCasePushLabel = 78;
        oCountPush = 79; { (13) }
        oCountPushValue = 80;
        oCountPop = 81;
        oCountIncrement = 82;
        oCountDecrement = 83;
        oCountChoose = 84; { >>13 }
        oFixPushForwardBranch = 85;
        oFixPopForwardBranch = 86;
        oFixPushTargetAddress = 87;
        oFixPopTargetAddress = 88;
        oFixPopAndEnterValue = 89;
        oFixSwap = 90;

        { Input Tokens }
        sIdentifier = 0;
        firstSemanticToken = 0;
        firstCompoundSemanticToken = 0;
        sInteger = 1;
        sStringLiteral = 2;
        lastCompoundSemanticToken = 2;
        sProgram = 3;
        sParmBegin = 4;
        sParmEnd = 5;
        sConst = 6;
        sType = 7;
        sVar = 8;
        sProcedure = 9;
        sBegin = 10;
        sEnd = 11;
        sNegate = 12;
        sArray = 13;
        sFile = 14;
        sRange = 15;
        sCaseStmt = 16;
        sCaseEnd = 17;
        sLabelEnd = 18;
        sExpnEnd = 19;
        sNullStmt = 20;
        sAssignmentStmt = 21;
        sSubscript = 22;
        sCallStmt = 23;
        sFieldWidth = 24;
        sIfStmt = 25;
        sThen = 26;
        sElse = 27;
        sWhileStmt = 28;
        sRepeatStmt = 29;
        sRepeatEnd = 30;
        sEq = 31;
        sNE = 32;
        sLT = 33;
        sLE = 34;
        sGT = 35;
        sGE = 36;
        sAdd = 37;
        sSubtract = 38;
        sMultiply = 39;
        sDivide = 40;
        sModulus = 41;
        sInfixOr = 42;
        sOr = 43;
        sInfixAnd = 44;
        sAnd = 45;
        sNot = 46;
        sNewLine = 47;
        sEndOfFile = 48;
        lastSemanticToken = 48;

        { Output Tokens }
        tMultiply = 0;
        firstTcode = 0;
        tDivide = 1;
        tModulus = 2;
        tAdd = 3;
        tSubtract = 4;
        tEQ = 5;
        tNE = 6;
        tGT = 7;
        tGE = 8;
        tLT = 9;
        tLE = 10;
        tAnd = 11;
        tInfixAnd = 12;
        tOr = 13;
        tInfixOr = 14;
        tNegate = 15;
        tNot = 16;
        tChr = 17;
        tOrd = 18;
        tEoln = 19;
        tEOF = 20;
        tVarParm = 21;
        tFetchAddress = 22;
        tFetchInteger = 23;
        tFetchChar = 24;
        tFetchBoolean = 25;
        tAssignBegin = 26;
        tAssignAddress = 27;
        tAssignInteger = 28;
        tAssignChar = 29;
        tAssignBoolean = 30;
        tStoreAddress = 31;
        tStoreInteger = 32;
        tStoreChar = 33;
        tStoreBoolean = 34;
        tSubscriptBegin = 35;
        tSubscriptAddress = 36;
        tSubscriptInteger = 37;
        tSubscriptChar = 38;
        tSubscriptBoolean = 39;
        tArrayDescriptor = 40;
        tFileDescriptor = 41;
        tFileBind = 42;
        tIfBegin = 43;
        tIfEnd = 44;
        tCaseBegin = 45;
        tWhileBegin = 46;
        tRepeatBegin = 47;
        tRepeatControl = 48;
        tCallBegin = 49;
        tParmEnd = 50;
        tProcedureEnd = 51;
        tWriteBegin = 52;
        tReadBegin = 53;
        tTrapBegin = 54;
        tWriteEnd = 55;
        tReadEnd = 56;
        tLiteralAddress = 57;
        firstCompoundTcode = 57;
        tLiteralInteger = 58;
        tLiteralChar = 59;
        tLiteralBoolean = 60;
        tSkipString = 61;
        tStringData = 62;
        tLiteralString = 63;
        tIfThen = 64;
        tIfMerge = 65;
        tCaseSelect = 66;
        tCaseMerge = 67;
        tCaseEnd = 68;
        tWhileTest = 69;
        tWhileEnd = 70;
        tRepeatTest = 71;
        tSkipProc = 72;
        tCallEnd = 73;
        tLineNumber = 74;
        tTrap = 75;
        lastCompoundTcode = 75;
        tEndOfFile = 76;
        lastTcode = 76;

        { Input/Output Tokens }

        { Error Codes }
        eDuplicateName = 10;
        firstErrorCode = 10;
        eMultiplyDefined = 11;
        eUndefinedIdentifier = 12;
        eConstantReqd = 13;
        eNullString = 14;
        eSubrangeReqd = 15;
        eScalarReqd = 16;
        eIntegerConstReqd = 17;
        eBounds = 18;
        eSimpleTypeReqd = 19;
        eExternalUndeclared = 20;
        eExternalDeclare = 21;
        eFileVarReqd = 22;
        eFileNameReqd = 23;
        eOperandOperatorTypeMismatch = 24;
        eNonScalarValParm = 25;
        eParameterTypeMismatch = 26;
        eInsufficientActuals = 27;
        eExtraActuals = 28;
        eRecursiveCall = 29;
        eProcedureReqd = 30;
        eTypeIdentifierReqd = 31;
        eIntegerExpnReqd = 32;
        eBooleanExpnReqd = 33;
        eCharExpnReqd = 34;
        eArrayVarReqd = 35;
        eVariableReqd = 36;
        eDuplicateLabel = 37;
        eExpnOperandReqd = 38;
        eTypeMismatch = 39;
        eInvalidExpn = 40;
        eInputNotVisible = 41;
        eOutputNotVisible = 42;
        eFieldWidth = 43;
        eTextFileVarReqd = 44;
        eWriteExpn = 45;
        eReadVar = 46;
        lastSslErrorCode = 46;

        { Type Values }
        { Type 13 }
        zero = 0;
        one = 1;
        two = 2;
        three = 3;
        ten = 10;
        byteSize = 1;
        wordSize = 4;
        { Type 14 }
        no = 0;
        yes = 1;
        { Type 15 }
        firstPredeclaredId = 1;
        firstPredeclaredType = 1;
        pidInteger = 1;
        pidChar = 2;
        pidBoolean = 3;
        pidText = 4;
        lastPredeclaredType = 4;
        pidTrue = 5;
        pidFalse = 6;
        pidReset = 7;
        pidRewrite = 8;
        pidWrite = 9;
        pidWriteln = 10;
        pidRead = 11;
        pidReadln = 12;
        pidChr = 13;
        pidOrd = 14;
        pidEoln = 15;
        pidEof = 16;
        pidAssign = 17;
        lastPredeclaredId = 17;
        pidInput = 18;
        firstSpecialId = 18;
        pidOutput = 19;
        lastSpecialId = 19;
        { Type 16 }
        stdInteger = 0;
        stdChar = 1;
        stdBoolean = 2;
        stdText = 3;
        { Type 17 }
        syConstant = 0;
        syType = 1;
        syVariable = 2;
        syVarParameter = 3;
        syProcedure = 4;
        syFunction = 5;
        syExternal = 6;
        syExpression = 7;
        syUndefined = 8;
        { Type 18 }
        rtReset = 1;
        rtRewrite = 2;
        rtWrite = 3;
        rtWriteln = 4;
        rtRead = 5;
        rtReadln = 6;
        rtOrd = 7;
        rtChr = 8;
        rtEoln = 9;
        rtEof = 10;
        rtAssign = 11;
        rtNull = 12;
        { Type 19 }
        stdInput = 0;
        stdOutput = 1;
        stdNull = 2;
        { Type 20 }
        tpInteger = 0;
        tpChar = 1;
        tpBoolean = 2;
        tpSubrange = 3;
        tpArray = 4;
        tpString = 5;
        tpFile = 6;
        tpNull = 7;
        { Type 21 }
        trHalt = 0;
        trReset = 1;
        trRewrite = 2;
        trRead = 3;
        trReadln = 4;
        trWrite = 5;
        trWriteln = 6;
        trWriteString = 7;
        trWriteInteger = 8;
        trWriteChar = 9;
        trReadInteger = 10;
        trReadChar = 11;
        trAssign = 12;

        { S/SL Rule Table Addresses } {
        Program = 0;
        ProgramParameter = 45;
        Block = 111;
        AllocateVar = 693;
        ProcedureDefinition = 777;
        ConstantDefinitions = 147;
        TypeDefinitions = 272;
        VariableDeclarations = 616;
        BeginStmt = 1123;
        ConstantValue = 187;
        SymbolStkPushDefaultIntegerConstant = 3812;
        StringLiteral = 1727;
        TypeBody = 310;
        IndexType = 348;
        ComponentType = 383;
        SimpleType = 409;
        TypeTblEnterIfNew = 338;
        ValuePushValuePlusOne = 3803;
        SubrangeUpperBound = 554;
        EnterVariableAttributes = 647;
        ProcedureHeading = 833;
        ProcedureParameterType = 879;
        ProcedurePrologue = 942;
        CountPushCopy = 3808;
        EmitStore = 1096;
        Statement = 987;
        AssignmentStmt = 1041;
        CallStmt = 1137;
        IfStmt = 1376;
        WhileStmt = 1407;
        CaseStmt = 1448;
        RepeatStmt = 1424;
        Variable = 2187;
        Expression = 1598;
        CompareAndSwapTypes = 1961;
        EmitAssign = 1069;
        OpenProcedure = 2587;
        AssignProcedure = 2618;
        WriteProcedure = 2725;
        WritelnProcedure = 3197;
        ReadProcedure = 3255;
        ReadlnProcedure = 3617;
        ActualParameters = 1270;
        FlushActuals = 3883;
        VarActual = 1338;
        BooleanControlExpression = 3788;
        CaseSelectorExpression = 3771;
        CaseAlternative = 1494;
        Operand = 1626;
        UnaryOperator = 1784;
        BinaryOperator = 1816;
        FlushExpn = 3862;
        ConstantOperand = 2298;
        VariableOperand = 2337;
        FunctionOperand = 2364;
        SymbolStkPushDefaultIntegerVariable = 3845;
        FileOperand = 2562;
        CompareOperandAndResultTypes = 2061;
        CompareEqualityOperandTypes = 2122;
        CompareRelationalOperandTypes = 2072;
        VariableExtension = 2229;
        StandardFunctionActual = 2467;
        FileVariable = 3675;
        WriteText = 2992;
        WriteBinary = 3113;
        WriteStandardExpnList = 2946;
        TextFileVariable = 3716;
        ReadTextParameterList = 3385;
        ReadBinaryParameterList = 3451;
        ReadText = 3517;
        ReadBinary = 3546;
        SymbolStkPushDefaultCharConstant = 3828;
        }

        { S/SL Table Parameters }
        sslTblSize = 3902;
        minSslTableValue = -32767;
        maxSslTableValue = 32767;

{ ===== End of contents of semantic.def }

        { firstFatalErrorCode MUST be bigger than lastSslErrorCode }
        firstFatalErrorCode = 50;
        eSslStackOverflow = 50;
        eSymbolTblOvfl = 51;
        eSymbolStkOvfl = 52;
        eTypeTblOvfl = 53;
        eTypeStkOvfl = 54;
        eCountStackOvfl = 55;
        eFixStackOvfl = 56;
        eValueStackOvfl = 57;
        eCaseDisplayOvfl = 58;
        eCaseRange = 59;
        eCaseStackOvfl = 60;
        eLexicLevelStackOvfl = 61;
        ePatchTableOvfl = 62;
        eIdentTableOvfl = 63;
        lastErrorCode = 63;

        { S/SL System Failure Codes }
        firstFailureCode = 0;
        fSemanticChoiceFailed = 0;
        fChoiceRuleFailed = 1;
        lastFailureCode = 1;

        { Assertion statement identification values. }
        assert1 = 1;
        assert2 = 2;
        assert3 = 3;
        assert4 = 4;
        assert5 = 5;
        assert6 = 6;
        assert7 = 7;
        assert8 = 8;
        assert9 = 9;
        assert10 = 10;
        assert11 = 11;
        assert12 = 12;
        assert13 = 13;
        assert14 = 14;
        assert15 = 15;
        assert16 = 16;
        assert17 = 17;
        assert18 = 18;
        assert19 = 19;
        assert20 = 20;
        assert21 = 21;
        assert22 = 22;
        assert23 = 23;
        assert24 = 24;
        assert25 = 25;
        assert26 = 26;
        assert27 = 27;
        assert28 = 28;
        assert29 = 29;
        assert30 = 30;
        assert31 = 31;
        assert32 = 32;
        assert33 = 33;
        assert34 = 34;
        assert35 = 35;
        assert36 = 36;
        assert37 = 37;
        assert38 = 38;
        assert39 = 39;
        assert40 = 40;
        assert41 = 41;
        assert42 = 42;
        assert43 = 43;
        assert44 = 44;
        assert45 = 45;
        assert46 = 46;
        assert47 = 47;
        assert48 = 48;
        assert49 = 49;
        assert50 = 50;
        assert51 = 51;
        assert52 = 52;
        assert53 = 53;
        assert54 = 54;
        assert55 = 55;
        assert56 = 56;
        assert57 = 57;
        assert58 = 58;
        assert59 = 59;

        { The S/SL Rule Call Stack Size }
        sslStackSize = 127;

        { Maximum Source Lines }
        maxLineNumber = 9999;

        { Maximum Error Count }
        maxErrors = 20;

        { Semantic data structure sizes }
        { Ident table size should be the same as the corresponding constant in the Scanner/Parser. }
        identTblSize = 1601;
        symbolTblSize = 1500;
        typeTblSize = 350;
        lexicLevelStackSize = 14;       { limits procedure nesting }
        symbolStkSize = 40;
        typeStkSize = 60;
        caseDisplaySize = 8;            { case nesting limit }
        caseStackSize = 256;            { limits number of labels in a case }
        { Case max range limits the difference between the smallest and largest label values 
          (i.e. the size of case branching tables. }
        caseMaxRange = 256;
        valueStackSize = 14;
        countStackSize = 14;
        fixStackSize = 250;
        patchTableSize = 1000;
        maxTokenLength = 200;           { corresponds to parser maximum }
        sslTableSize = 5000;
        minInteger = -32767;
        maxInteger = 32767;
        minusOne = -1;
        null = 0;
        undefined = minInteger;

        { Parser generated identifier table indices }
        standardInputNameIndex = pidInput;      
        standardOutputNameIndex = pidOutput;    

    type
        InputTokens = firstSemanticToken .. lastSemanticToken;
        ErrorCodes = firstErrorCode .. lastErrorCode;

        { S/SL System Failure Code Type }
        FailureCodes = firstFailureCode .. lastFailureCode;

        SymbolKinds = syConstant .. syUndefined;
        TypeKinds = tpInteger .. tpNull;
        SymbolTblReference = 0 .. symbolTblSize;
        SymbolStkReference = 0 .. symbolStkSize;
        TypeTblReference = 0 .. typeTblSize;
        TypeStkReference = 0 .. typeStkSize;
        IdentTblReference = 0 .. identTblSize;
        CaseStackReference = 0 .. caseStackSize;

    var
        { The Syntax/Semantic Table;
          The S/SL table file produced by the S/SL Processor for the pass is read 
          into this array during initialization. }
        sslTable: array [0 .. sslTableSize] of minSslTableValue .. maxSslTableValue;
        semanticSsl: file of integer;

        { Table Walker State }
        processing: Boolean             { initially true };
        sslPointer: 0 .. sslTableSize   { initially 0 };
        operation: integer;

        { Tracing Control }
        options: text;
        tracing: Boolean   { initially false };

        { Abort flag }
        sslabort: Boolean  { initially false};

        { The S/SL Rule Call Stack:
          The Rule Call Stack implements Syntax/Semantic Language rule call and return.
          Each time an oCall operation is executed, the table return address is pushed 
          onto the Rule Call Stack.  When an oReturn is executed, the return address is 
          popped from the stack.  An oReturn executed when the Rule Call Stack is empty 
          terminates table execution. }
        sslStack: array [1 .. sslStackSize] of 0 .. sslTableSize;
        sslTop:   0 .. sslStackSize  { initially 0 };

        { Choice Match Flag:
          Set by the Choice Handler to indicate whether a match was made or the otherwise 
          path was taken.  Set to true if a match was made and false otherwise.  
          This flag is used in input choices to indicate whether the choice input token 
          should be accepted or not. }
        choiceTagMatched: Boolean;

        { Parameterized And Choice Semantic Operation Values:
          These are used to hold the decoded parameter value to a parameterized semantic 
          operation and the result value returned by a choice semantic operation or 
          rule respectively. }
        parameterValue: integer;
        resultValue:    integer;

        { Line Counters }
        nextLineNumber: 0 .. maxLineNumber              { initially 1 };
        lineNumber:     0 .. maxLineNumber;
        lastEmittedLineNumber: 0 .. maxLineNumber;      { initially 0 }

        { Error Counter }
        noErrors: 0 .. maxErrors  { initially 0 };

        { Input Interface }
        parseStream: file of integer;
        nextInputToken: InputTokens;

        { The Compound Input Token Buffer;
          When a compound input token is accepted from the input stream, 
          its associated value is saved in the compound token buffer for use by 
          the Semantic Mechanisms of the pass. }
        compoundToken: InputTokens;               { Last compound input token accepted }
        compoundTokenValue: integer;              { Its associated value }
        compoundTokenLength: 0 .. maxTokenLength; { Its associated length }
        { (The ord of) its character representation if it
          is a literal string or an external procedure name }
        compoundTokenText: array [1 .. maxTokenLength] of integer;

        { Output Interface }
        { Unpatched code area (t-code) }
        temp:  file of integer;
        { t-code header and patched code area (t-code) }
        tCode: file of integer;

        { Global Temporaries }
        i: integer;
        j: integer;

        { Ident Table }
        identSymbolTblRef:  array [1 .. identTblSize] of integer;

        { Symbol Table }
        symbolTblIdentLink:     array [1 .. symbolTblSize] of integer;
        symbolTblKind:          array [1 .. symbolTblSize] of SymbolKinds;
        symbolTblValue:         array [1 .. symbolTblSize] of integer;
        symbolTblTypeTblLink:   array [1 .. symbolTblSize] of TypeTblReference;
        symbolTblTop:  SymbolTblReference;      { initially 0 }

        { Lexic Level Stack }
        symbolTblDisplay:  array [1 .. lexicLevelStackSize] of SymbolTblReference;
        typeTblDisplay:    array [1 .. lexicLevelStackSize] of TypeTblReference;
        lexicLevelStackTop:  0 .. lexicLevelStackSize;   { initially 0 }

        { Symbol Stack }
        symbolStkIdentTblRef:   array [1 .. symbolStkSize] of integer;
        symbolStkSymbolTblRef:  array [1 .. symbolStkSize] of SymbolTblReference;
        symbolStkKind:          array [1 .. symbolStkSize] of SymbolKinds;
        symbolStkValue:         array [1 .. symbolStkSize] of integer;
        symbolStkTypeTblLink:   array [1 .. symbolStkSize] of TypeTblReference;
        symbolStkTop:  SymbolStkReference;      { initially 0 }

        { Type Table }
        typeTblKind:            array [1 .. typeTblSize] of TypeKinds;
        typeTblLowerBound:      array [1 .. typeTblSize] of integer;
        typeTblUpperBound:      array [1 .. typeTblSize] of integer;
        typeTblComponentLink:   array [1 .. typeTblSize] of TypeTblReference;
        typeTblTop:  TypeTblReference;          { initially 0 }

        { Type Stack }
        typeStkTypeTblRef:      array [1 .. typeStkSize] of TypeTblReference;
        typeStkKind:            array [1 .. typeStkSize] of TypeKinds;
        typeStkLowerBound:      array [1 .. typeStkSize] of integer;
        typeStkUpperBound:      array [1 .. typeStkSize] of integer;
        typeStkComponentLink:   array [1 .. typeStkSize] of TypeTblReference;
        typeStkTop:  TypeStkReference;          { initially 0 }

        { Count Stack }
        countStack:     array [1 .. countStackSize] of integer;
        countStackTop:  0 .. countStackSize;    { initially 0 }

        { Fix Address Stack }
        fixStack:       array [1 .. fixStackSize] of integer;
        fixStackTop:    0 .. fixStackSize;      { initially 0 }

        { Value Stack }
        valueStack:     array [1 .. valueStackSize] of integer;
        valueStackTop:  0 .. valueStackSize;    { initially 0 }

        { Case Stack }
        caseDisplay:    array [1 .. caseDisplaySize] of CaseStackReference;
        caseDisplayTop: 0 .. caseDisplaySize;   { initially 0 }

        caseLabelStack:         array [1 .. caseStackSize] of integer;
        caseAddressStack:       array [1 .. caseStackSize] of integer;
        caseStackTop:   0 .. caseStackSize;     { initially 0 }

        { Data Area Allocation }
        dataAreaEnd:  integer;          { initially 0 }

        { Code Area }
        codeAreaEnd:  integer;          { initially 0 }

        { Code Area Patch Table }
        patchAddresses: array [1 .. patchTableSize] of integer;
        patchValues:    array [1 .. patchTableSize] of integer;
        patchTableTop:  0 .. patchTableSize;    { initially 0 }

        { Predefined type table entries }
        standardIntegerTypeRef: TypeTblReference;
        standardCharTypeRef:    TypeTblReference;
        standardBooleanTypeRef: TypeTblReference;
        standardTextTypeRef:    TypeTblReference;
        
        { UNIX argument file identifiers, for gpc compatibility }
        {==
        NsemanticSsl, NparseStream, Ntemp, NtCode, Noptions: array [1 .. 50] of char;
        ==}


    procedure Assert (assertion: Boolean; number: integer);
        { Procedure to implement programmer assertion checking with identification numbers. }
        begin
            if not assertion then
                begin
                    write ('### Semantic assertion ', number: 1, ' failed: ');

                    case number of
                        assert1:
                            write ('value stack empty in oFixPopAndEnterValue');
                        assert2:
                            write ('compound token is not an identifier in oSymbolStkPushIdentifier');
                        assert3, assert4:
                            ; { Problem message already reported }
                        assert5:
                            write ('null symbol table ref in oSymbolTblUpdate');
                        assert6:
                            write ('empty lexic level stack in oSymbolTblLookupExternal');
                        assert7:
                            write ('empty symbol stack in oSymbolStkPop');
                        assert8:
                            write ('null type table ref in oTypeTblUpdate');
                        assert9:
                            write ('type is stdText in oTypeStkLinkToStandardType');
                        assert10:
                            write ('less than two values in value stack in oTypeStkEnterBounds');
                        assert11:
                            write ('less than two types in type stack in oTypeStkEnterComponentReference');
                        assert12:
                            write ('null type table ref in oTypeStkEnterComponentReference');
                        assert13:
                            write ('less than two types in type stack in oTypeStkCompareNames');
                        assert14, assert15:
                            write ('null type table ref in oTypeStkCompareNames');
                        assert16:
                            write ('less than two types in type stack in oTypeStkSwap');
                        assert17:
                            write ('empty type stack in oTypeStkPop');
                        assert18:
                            write ('empty count stack in oCountPop');
                        assert19:
                            write ('empty value stack in oCountPushValue');
                        assert20:
                            write ('empty value stack in oValuePop');
                        assert21:
                            write ('empty case display stack in oCasePopDisplay');
                        assert22:
                            write ('sslTableSize too small (increase in semantic.pt)');
                        assert23:
                            write ('compound token is not an identifier in oSymbolStkPushLocalIdentifier');
                        assert24:
                            write ('top of symbol stack is not a procedure in oSymbolStkPushFormalParameter');
                        assert25:
                            write ('compound token is not a string literal in oSymbolStkEnterStringValue');
                        assert26:
                            write ('null type table ref in oSymbolStkEnterTypeReference');
                        assert27:
                            write ('top of symbol stack is not a procedure in oSymbolStkChooseStandardRoutine');
                        assert28:
                            write ('top of symbol stack is not a procedure in oTypeStkEnterParameterCount');
                        assert29:
                            write ('top of symbol stack is not a procedure in oTypeStkCompareParameterCount');
                        assert30, assert58:
                            write ('internal error in semantic.pt (report to maintainer)');
                        assert31:
                            write ('empty lexic level stack in oSymbolTblPopScope');
                        assert32:
                            write ('empty fix stack in oFixPopTargetAddress');
                        assert33:
                            write ('empty fix stack in oFixPopForwardBranch');
                        assert34:
                            write ('invalid code address patch (missing oEmitNullAddress after branch instruction)');
                        assert35:
                            write ('less than two entries in fix stack in oFixSwap');
                        assert36:
                            write ('compound token is not an integer literal in oValuePushInteger');
                        assert37:
                            write ('compound token is not a string literal in oValuePushStringLength');
                        assert38:
                            write ('empty count stack in oValuePushCount');
                        assert39:
                            write ('empty value stack in oValueNegate');
                        assert40:
                            write ('empty value stack in oValueChoose');
                        assert41:
                            write ('empty value stack in oCasePushLabel');
                        assert42:
                            write ('empty case display stack in oCaseLookupLabel');
                        assert43:
                            write ('empty value stack in oCaseLookupLabel');
                        assert44:
                            write ('empty value stack in oEmitValue');
                        assert45:
                            write ('compound token is not a string literal in oEmitString');
                        assert46:
                            write ('parent symbol is not procedure in oSymbolTblPreserveParameters');
                        assert47:
                            write ('semantic phase ended without consuming all of semantic token stream');
                        assert48:
                            write ('empty fix stack in oFixPopAndEnterValue');
                        assert49:
                            write ('symbol stack not empty at end of semantic phase');
                        assert50:
                            write ('type stack not empty at end of semantic phase');
                        assert51:
                            write ('lexic level stack not empty at end of semantic phase');
                        assert52:
                            write ('count stack not empty at end of semantic phase');
                        assert53:
                            write ('value stack not empty at end of semantic phase');
                        assert54:
                            write ('fix stack not empty at end of semantic phase');
                        assert55:
                            write ('case stack not empty at end of semantic phase');
                        assert56:
                            write ('case display stack not empty at end of semantic phase');
                        assert57:
                            ; { Unused }
                    end;

                    writeln;
                    write ('while processing line ', lineNumber);
                    writeln;

                    processing := false;
                    sslabort := true;
                end;
        end { Assert };


    procedure Initialize;
        { Enter predefined identifiers into the symbol and type tables, 
          initialize the semantic data structures, open the input and output streams, 
          and read the options file. }
        var
            c: char;

        begin
            { UNIX argument file identifiers, for gpc compatibility }
            {==
            argv (1, NsemanticSsl);
            argv (2, NparseStream);
            argv (3, Ntemp);
            argv (4, NtCode);
            argv (5, Noptions);
            ==}

            { Trace Execution if Required }
            tracing := false;
            reset (options {==, Noptions ==} );

            while not eof (options) do
                begin
                    read (options, c);

                    if c = 't' then
                        begin
                            read (options, c);
                            tracing := (c = '3');
                        end;
                end;

            noErrors := 0;
            sslabort := false;

            { Initialize S/SL Input/Output streams }
            rewrite (temp {==, Ntemp ==} );
            reset (parseStream {==, NparseStream ==} );
            nextInputToken := sNewLine;
            nextLineNumber := 1;
            lastEmittedLineNumber := 0;

            { Read in the S/SL Table }
            reset (semanticSsl {==, NsemanticSsl ==} );
            i := 0;
            while not eof(semanticSsl) do
                begin
                    if i > sslTableSize then
                        Assert(false, assert22);
                    read(semanticSsl, sslTable[i]);
                    i := i + 1;
                end;

            { Initialize symbol and type table entries for the predeclared identifiers. 
              The parser has assigned the predeclared identifiers to the first entries 
              in the semantic pass identifier table.  Use this knowledge to link the 
              identifier and symbol table entries for predeclared identifiers.  
              The order of the predeclared identifiers in the parser's stdIdentifier 
              file must exactly match the order here. }

            { Initialize the identifier table }
            i := 1;
            while i <= identTblSize do
                begin
                    identSymbolTblRef[i] := -i;
                    i := i + 1;
                end;

            { Link the symbol and identifier table entries }
            i := firstPredeclaredId;
            while i <= lastPredeclaredId do
                begin
                    identSymbolTblRef[i] := i;
                    symbolTblIdentLink[i] := -i;
                    i := i + 1;
                end;

            { Enter standard identifiers in the symbol and type tables. 
              The symbol and type table entries for predefined identifiers have 
              the same table index as the identifier itself. }

            { integer }
            symbolTblKind[pidInteger] := syType;
            symbolTblTypeTblLink[pidInteger] := pidInteger;
            typeTblKind[pidInteger] := tpInteger;
            { This index is used by the semantic mechanisms to link to predefined type integer; 
              similarly for char, Boolean and text. }
            standardIntegerTypeRef := pidInteger;

            { char }
            symbolTblKind[pidChar] := syType;
            symbolTblTypeTblLink[pidChar] := pidChar;
            typeTblKind[pidChar] := tpChar;
            standardCharTypeRef := pidChar;

            { Boolean }
            symbolTblKind[pidBoolean] := syType;
            symbolTblTypeTblLink[pidBoolean] := pidBoolean;
            typeTblKind[pidBoolean] := tpBoolean;
            standardBooleanTypeRef := pidBoolean;

            { text (i.e. file of char) }
            symbolTblKind[pidText] := syType;
            symbolTblTypeTblLink[pidText] := pidText;
            typeTblKind[pidText] := tpFile;
            typeTblComponentLink[pidText] := standardCharTypeRef;
            standardTextTypeRef := pidText;

            { true (1) }
            symbolTblKind[pidTrue] := syConstant;
            symbolTblValue[pidTrue] := 1;
            symbolTblTypeTblLink[pidTrue] := standardBooleanTypeRef;

            { false (0) }
            symbolTblKind[pidFalse] := syConstant;
            symbolTblValue[pidFalse] := 0;
            symbolTblTypeTblLink[pidFalse] := standardBooleanTypeRef;

            { Standard routines are distinguished from user routines by negative value fields; 
              a user defined routine has its code address in this field. }

            { reset }
            symbolTblKind[pidReset] := syProcedure;
            symbolTblValue[pidReset] := -rtReset;

            { rewrite }
            symbolTblKind[pidRewrite] := syProcedure;
            symbolTblValue[pidRewrite] := -rtRewrite;

            { write }
            symbolTblKind[pidWrite] := syProcedure;
            symbolTblValue[pidWrite] := -rtWrite;

            { writeln }
            symbolTblKind[pidWriteln] := syProcedure;
            symbolTblValue[pidWriteln] := -rtWriteln;

            { read }
            symbolTblKind[pidRead] := syProcedure;
            symbolTblValue[pidRead] := -rtRead;

            { readln }
            symbolTblKind[pidReadln] := syProcedure;
            symbolTblValue[pidReadln] := -rtReadln;

            { chr }
            symbolTblKind[pidChr] := syFunction;
            symbolTblValue[pidChr] := -rtChr;

            { ord }
            symbolTblKind[pidOrd] := syFunction;
            symbolTblValue[pidOrd] := -rtOrd;

            { eoln }
            symbolTblKind[pidEoln] := syFunction;
            symbolTblValue[pidEoln] := -rtEoln;

            { eof }
            symbolTblKind[pidEof] := syFunction;
            symbolTblValue[pidEof] := -rtEof;

            { assign }
            symbolTblKind[pidAssign] := syProcedure;
            symbolTblValue[pidAssign] := -rtAssign;

            Assert(lastPredeclaredId = pidAssign, assert58);

            symbolTblTop := lastPredeclaredId;  { number of predefined symbols entered above }
            typeTblTop := lastPredeclaredType;  { number of predefined types entered above }

            lexicLevelStackTop := 0;
            symbolStkTop := 0;
            typeStkTop := 0;
            countStackTop := 0;
            valueStackTop := 0;
            fixStackTop := 0;
            caseDisplayTop := 0;
            caseStackTop := 0;
            patchTableTop := 0;
            codeAreaEnd := 0;
            dataAreaEnd := 0;

        end;    { Initialize }


    procedure Error (errCode: ErrorCodes);
        { This procedure Emits the error message associated with errCode }
        begin
            { Semantic errors are in the accepted token }
            write ('semantic error, line ', lineNumber: 1, ': ');

            case errCode of
                eDuplicateName:
                    write('identifier repeated in list');
                eMultiplyDefined:
                    write('identifier declared twice');
                eUndefinedIdentifier:
                    write('identifier not declared');
                eConstantReqd:
                    write('constant required');
                eNullString:
                    write('null literal string not allowed');
                eSubrangeReqd:
                    write('subrange type required');
                eScalarReqd:
                    write('scalar type required');
                eIntegerConstReqd:
                    write('integer constant required');
                eBounds:
                    write('subrange lower bound exceeds upper bound');
                eSimpleTypeReqd:
                    write('subrange or named type required');
                eExternalUndeclared:
                    write('undeclared external file (program parameter)');
                eExternalDeclare:
                    write('program parameter must be a file variable');
                eFileVarReqd:
                    write('file variable required');
                eFileNameReqd:
                    write('file name string required');
                eOperandOperatorTypeMismatch:
                    write('operand and operator types clash');
                eNonScalarValParm:
                    write('value parameter must be a scalar');
                eParameterTypeMismatch:
                    write('formal and actual parameter types clash');
                eInsufficientActuals:
                    write('not enough actual parameters supplied');
                eExtraActuals:
                    write('too many actual parameters supplied');
                eRecursiveCall:
                    write('recursion not allowed');
                eProcedureReqd:
                    write('procedure name required');
                eTypeIdentifierReqd:
                    write('type identifier required');
                eIntegerExpnReqd:
                    write('integer type expression required');
                eBooleanExpnReqd:
                    write('Boolean type expression required');
                eCharExpnReqd:
                    write('char type expression required');
                eArrayVarReqd:
                    write('array variable required');
                eVariableReqd:
                    write('variable required');
                eDuplicateLabel:
                    write('duplicate case label value');
                eExpnOperandReqd:
                    write('expression operand required');
                eTypeMismatch:
                    write('type clash');
                eInvalidExpn:
                    write('invalid expression');
                eInputNotVisible:
                    write('standard input not a program parameter or redeclared locally');
                eOutputNotVisible:
                    write('standard output not a program parameter or redeclared locally');
                eFieldWidth:
                    write('invalid field width specification');
                eWriteExpn:
                    write('invalid write expression');
                eTextFileVarReqd:
                    write('text file required');
                eReadVar:
                    write('invalid read variable');
                eSslStackOverflow:
                    write ('Nesting too deep');
                eSymbolTblOvfl:
                    write('too many symbols  (symbol table)');
                eSymbolStkOvfl:
                    write('too many symbols  (symbol stack)');
                eTypeTblOvfl:
                    write('too many types  (type table)');
                eTypeStkOvfl:
                    write('too many types  (type stack)');
                eCountStackOvfl:
                    write('program too complicated  (S count stack)');
                eFixStackOvfl:
                    write('program too complicated  (S fix stack)');
                eValueStackOvfl:
                    write('program too complicated  (S value stack)');
                eCaseDisplayOvfl:
                    write('case nesting too deep  (case display)');
                eCaseRange:
                    write('case range (largest - smallest label) too large');
                eCaseStackOvfl:
                    write('too many labels in case  (case stack)');
                eLexicLevelStackOvfl:
                    write('procedure nesting too deep (lexic level stack)');
                ePatchTableOvfl:
                    write('program too complicated (S patch table)');
                eIdentTableOvfl:
                    write('too many identifiers (identifier table)');
            end;

            writeln;
            noErrors := noErrors + 1;

            if (errCode >= firstFatalErrorCode) or (noErrors = maxErrors) then
                begin
                    write ('*** Processing aborted');
                    writeln;
                    sslabort := true;
                    processing := false;
                end;

        end  { Error };


    procedure EmitOutputToken (emittedToken: integer);
        { Emit an output token to the temp (unpatched t-code) stream }
        begin
            { Line number tokens are emitted only after a change in the
              line number value and before emission of a non-line number token }
            if lineNumber <> lastEmittedLineNumber then
                begin
                    write(temp, tLineNumber);
                    write(temp, lineNumber);
                    codeAreaEnd := codeAreaEnd + 2;
                    lastEmittedLineNumber := lineNumber;
                end;

            write (temp, emittedToken);
            codeAreaEnd := codeAreaEnd + 1;

            { Trace Output }
            if tracing then
                begin
                    write ('Output token emitted ', emittedToken: 1);
                    writeln;
                end;

        end { EmitOutputToken };


    procedure AcceptInputToken;
        { This procedure provides the interface to the previous pass;  
          it is reponsible for handling all input including line number indicators 
          and the values and text associated with input tokens. }
        var
            acceptedToken: InputTokens;

        begin
            { Accept Token }
            acceptedToken := nextInputToken;

            { If the token is a compound token, read its associated value }
            if (acceptedToken = sIdentifier) or (acceptedToken = sInteger) then
                begin
                    compoundToken := acceptedToken;
                    read (parseStream, compoundTokenValue);
                    { Check that identifier values lie within the identifier table }
                    if (acceptedToken = sIdentifier) and (compoundTokenValue > identTblSize) then
                        Error(eIdentTableOvfl);
                end
            else if acceptedToken = sStringLiteral then
                begin
                    compoundToken := acceptedToken;
                    read(parseStream, compoundTokenLength);
                    i := 0;
                    while i < compoundTokenLength do
                        begin
                            i := i + 1;
                            read(parseStream, compoundTokenText[i]);
                        end
                end;

            { Update Line Number }
            lineNumber := nextLineNumber;

            { Read Next Input Token }
            repeat
                if eof(parseStream) then
                    nextInputToken := sEndOfFile
                else
                    read (parseStream, nextInputToken);

                if nextInputToken = sNewLine then
                    begin
                        { Update the line counter }
                        if nextLineNumber < maxLineNumber then
                            nextLineNumber := nextLineNumber + 1
                        else
                            nextLineNumber := 0;
                    end;
            until nextInputToken <> sNewLine;

            { Trace Input }
            if tracing then
                begin
                    write ('Input token accepted ', acceptedToken: 1, ';  Line ', lineNumber: 1, 
                        ';  Next input token ', nextInputToken: 1);
                    writeln;
                end;

        end { AcceptInputToken };


    { Semantic Mechanism Operation Routines }

    procedure SymbolStkPush(kind: SymbolKinds);
        { If the symbol stack is not full push an entry of the parameter kind, 
          otherwise report an error. }

        begin
            if symbolStkTop < symbolStkSize then
                begin
                    symbolStkTop := symbolStkTop + 1;
                    symbolStkKind[symbolStkTop] := kind;
                    symbolStkIdentTblRef[symbolStkTop] := null;
                    symbolStkSymbolTblRef[symbolStkTop] := null;
                    symbolStkTypeTblLink[symbolStkTop] := null;
                    symbolStkValue[symbolStkTop] := null;
                end
            else
                Error(eSymbolStkOvfl);

        end;    { SymbolStkPush }


    procedure SymbolStkPushIdentifier(symbolRef: SymbolTblReference);
        { If the symbol stack is not full, push an entry with the attributes of 
          the symbol table entry specified by the parameter and the last accepted 
          identifier name, otherwise report an error. }

        begin
            if symbolStkTop < symbolStkSize then
                begin
                    symbolStkTop := symbolStkTop + 1;
                    { The last compound token accepted must have been the identifier 
                      that we're pushing now. }
                    symbolStkIdentTblRef[symbolStkTop] := compoundTokenValue;
                    symbolStkSymbolTblRef[symbolStkTop] := symbolRef;
                    symbolStkKind[symbolStkTop] := symbolTblKind[symbolRef];
                    symbolStkValue[symbolStkTop] := symbolTblValue[symbolRef];
                    symbolStkTypeTblLink[symbolStkTop] :=
                        symbolTblTypeTblLink[symbolRef]
                end
            else
                Error(eSymbolStkOvfl);

        end;    { SymbolStkPushIdentifier }


    procedure TypeStkPush(kind: TypeKinds);
        { If the type stack is not full push an entry of the parameter kind, 
          otherwise report an error. }

        begin
            if typeStkTop < typeStkSize then
                begin
                    typeStkTop := typeStkTop + 1;
                    typeStkKind[typeStkTop] := kind;
                    typeStkTypeTblRef[typeStkTop] := null;
                    typeStkLowerBound[typeStkTop] := null;
                    typeStkUpperBound[typeStkTop] := null;
                    typeStkComponentLink[typeStkTop] := null;
                end
            else
                Error(eTypeStkOvfl)

        end;    { TypeStkPush }


    procedure TypeStkPushTypeTbl(typeRef: TypeTblReference);
        { If the type stack is not full, push an entry with the attributes of 
          the type table entry specified by the parameter, otherwise report an error. }

        begin
            if typeStkTop < typeStkSize then
                begin
                    typeStkTop := typeStkTop + 1;
                    typeStkTypeTblRef[typeStkTop] := typeRef;
                    typeStkKind[typeStkTop] := typeTblKind[typeRef];
                    typeStkLowerBound[typeStkTop] := typeTblLowerBound[typeRef];
                    typeStkUpperBound[typeStkTop] := typeTblUpperBound[typeRef];
                    typeStkComponentLink[typeStkTop] :=
                                typeTblComponentLink[typeRef];
                end
            else
                Error(eTypeStkOvfl);

        end;    { TypeStkPushTypeTbl }


    procedure TypeStkCopy(src: TypeStkReference;
                          dst: TypeStkReference);
        { Copy the type stack entry specified by the src parameter to the type stack entry 
          specified by the dst parameter. }

        begin
            typeStkTypeTblRef[dst] := typeStkTypeTblRef[src];
            typeStkKind[dst] := typeStkKind[src];
            typeStkLowerBound[dst] := typeStkLowerBound[src];
            typeStkUpperBound[dst] := typeStkUpperBound[src];
            typeStkComponentLink[dst] := typeStkComponentLink[src]
        end;    { TypeStkCopy }


    procedure ValueStackPush(value: integer);
        { If the value stack is not full, push the parameter value, otherwise report an error. }

        begin
            if valueStackTop < valueStackSize then
                begin
                    valueStackTop := valueStackTop + 1;
                    valueStack[valueStackTop] := value
                end
            else
                Error(eValueStackOvfl)

        end;    { ValueStackPush }


    procedure EmitCaseBranchTable;
        { Determine the minimum and maximum label values that occur in the case statement.  
          If the range of label values is greater than is allowed report an error, 
          otherwise emit the minimum and maximum values followed by the case branch table. }

        var
            min: integer;
            max: integer;
            base: CaseStackReference;

        begin
            min := maxInteger;
            max := minInteger;
            i := caseDisplay[caseDisplayTop];
            j := 0;
            while i < caseStackTop do
                begin
                    i := i + 1;
                    if caseLabelStack[i] < min then
                        min := caseLabelStack[i];
                    if caseLabelStack[i] > max then
                        max := caseLabelStack[i];
                end;

            if max - min > caseMaxRange then
                Error(eCaseRange)
            else
                begin
                    EmitOutputToken(min);
                    EmitOutputToken(max);
                    base := caseDisplay[caseDisplayTop];
                    { no sort so O(n**2/2) }
                    j := min;
                    repeat
                        i := base;
                        while i < caseStackTop do
                            begin
                                i := i + 1;
                                if caseLabelStack[i] = j then
                                    begin
                                        { Emit the tCode address of this label value. }
                                        EmitOutputToken(caseAddressStack[i]);
                                        i := caseStackTop + 1;  { exit }
                                    end
                            end;

                        if i <= caseStackTop then
                            { No label matched this value; emit a dummy null address. }
                            EmitOutputToken(minusOne);

                        j := j + 1;
                    until j > max;
                end

        end;    { EmitCaseBranchTable }


    procedure SslSyntaxError;
        { A syntax error in the semantic token stream implies a compiler failure.  
          Either the parser is generating an invalid stream or the semantic analyzer 
          expects an invalid stream. }
        begin
            write ('### Semantic pass S/SL program failure:  syntax error in semantic token stream');
            writeln;
            write ('    (parser output stream does not match expected input stream)');
            writeln;
            write ('while processing line ', lineNumber);
            writeln;
            Assert(false, assert3);
        end { SslSyntaxError };


    procedure SslTrace;
        begin
            write ('Table index ', sslPointer-1: 1, ';  Operation ', operation: 1, 
                ';  Argument ', sslTable[sslPointer]: 1);
            writeln;
        end  { SslTrace };


    procedure SslFailure (failCode: FailureCodes);
        begin
            write ('### Semantic pass S/SL program failure:  ');

            case failCode of
                fSemanticChoiceFailed:
                    write ('Semantic choice failed');
                fChoiceRuleFailed:
                    write ('Choice rule returned without a value');
            end;

            writeln;
            write ('while processing line ', lineNumber);
            writeln;
            SslTrace;
            Assert (false, assert4);
        end { SslFailure };


    procedure SslChoice (choiceTag: integer);
        { This procedure performs both input and semantic choices.  
          It sequentially tests each alternative value against the tag value, 
          and when a match is found, performs a branch to the corresponding alternative path.  
          If none of the alternative values matches the tag value, sslTable interpretation 
          proceeds to the operation immediately following the list of alternatives 
          (normally the otherwise path).  The flag choiceTagMatched is set to true
          if a match is found and false otherwise. }

        var numberOfChoices:
            integer;
        begin
            sslPointer := sslPointer + sslTable[sslPointer];
            numberOfChoices := sslTable[sslPointer];
            sslPointer := sslPointer + 1;
            choiceTagMatched := false;

            repeat
                if sslTable[sslPointer] = choiceTag then
                    begin
                        sslPointer := sslPointer + 1;
                        sslPointer := sslPointer - sslTable[sslPointer];
                        choiceTagMatched := true;
                        numberOfChoices := 0;
                    end
                else
                    begin
                        sslPointer := sslPointer + 2;
                        numberOfChoices := numberOfChoices - 1;
                    end;
            until numberOfChoices = 0;

            if tracing then
                begin
                    write ('Choice tag ', choiceTag: 1);
                    if choiceTagMatched then
                        write (' (matched)')
                    else
                        write (' (not matched)');
                    writeln
                end

        end { SslChoice };


    procedure SslWalker;
        { Walk the semantic analysis S/SL table }
        var
            symbolRef: SymbolTblReference;
            typeRef:   TypeTblReference;
            link: integer;
            byteOffset: 0 .. wordSize;
            size: integer;
            kind: typeKinds;

        begin
            { Initialize Table Walker State }
            processing := true;
            sslPointer := 0;
            sslTop := 0;
            AcceptInputToken;

            repeat
                operation := sslTable[sslPointer];
                sslPointer := sslPointer + 1;

                { Trace Execution }
                if tracing then
                    SslTrace;

                case operation of
                    oCall:
                        if sslTop < sslStackSize then
                            begin
                                sslTop := sslTop + 1;
                                sslStack[sslTop] := sslPointer + 1;
                                sslPointer := sslTable[sslPointer];
                            end
                        else
                            begin
                                Error (eSslStackOverflow);
                                processing := false;
                            end;

                    oReturn:
                        if sslTop = 0 then
                            { Return from main S/SL procedure }
                            processing := false
                        else
                            begin
                                sslPointer := sslStack[sslTop];
                                sslTop := sslTop - 1;
                            end;

                    oRuleEnd:
                        SslFailure (fChoiceRuleFailed);

                    oJumpForward:
                        sslPointer := sslPointer + sslTable[sslPointer];

                    oJumpBack:
                        sslPointer := sslPointer - sslTable[sslPointer];

                    oInput:
                        begin
                            if sslTable[sslPointer] = nextInputToken then
                                AcceptInputToken
                            else
                                { Syntax error in input }
                                SslSyntaxError;

                            sslPointer := sslPointer + 1;
                        end;

                    oInputAny:
                        if nextInputToken <> sEndOfFile then
                            AcceptInputToken
                        else
                            { Premature end of file }
                            SslSyntaxError;

                    oInputChoice:
                        begin
                            SslChoice (nextInputToken);
                            if choiceTagMatched then
                                AcceptInputToken;
                        end;

                    oEmit:
                        begin
                            EmitOutputToken (sslTable[sslPointer]);
                            sslPointer := sslPointer + 1;
                        end;

                    oError:
                        begin
                            Error (sslTable[sslPointer]);
                            sslPointer := sslPointer + 1;
                        end;

                    oChoice:
                        SslChoice (resultValue);

                    oChoiceEnd:
                        SslFailure (fSemanticChoiceFailed);

                    oSetParameter:
                        begin
                            parameterValue := sslTable[sslPointer];
                            sslPointer := sslPointer + 1;
                        end;

                    oSetResult:
                        begin
                            resultValue := sslTable[sslPointer];
                            sslPointer := sslPointer + 1;
                        end;


                    { Semantic Analysis Semantic Mechanisms }

                    { ****
                      *  *  Symbol Table Mechanism Operations
                      **** }

                    oSymbolTblEnter:
                        { Create a symbol table entry with the attributes of the top symbol stack 
                          entry and link it to the top symbol stack entry. }

                        if symbolTblTop < symbolTblSize then
                            begin
                                symbolTblTop := symbolTblTop + 1;
                                symbolTblKind[symbolTblTop] := symbolStkKind[symbolStkTop];
                                symbolTblValue[symbolTblTop] := symbolStkValue[symbolStkTop];
                                symbolTblTypeTblLink[symbolTblTop] := 
                                    symbolStkTypeTblLink[symbolStkTop];
                                symbolStkSymbolTblRef[symbolStkTop] := symbolTblTop;

                                { Update identifier table links }
                                link := symbolStkIdentTblRef[symbolStkTop];

                                if link > 0 then
                                    { This is a normal identifier, not a dummy identifier generated 
                                      by the parser's syntax error recovery procedure. }
                                    begin
                                        symbolTblIdentLink[symbolTblTop] := identSymbolTblRef[link];
                                        identSymbolTblRef[link] := symbolTblTop;
                                    end
                            end
                        else
                            Error(eSymbolTblOvfl);

                    oSymbolTblUpdate:
                        { Copy the attributes of the top symbol stack entry to 
                          the symbol table entry it references. }

                        begin
                            Assert((symbolStkSymbolTblRef[symbolStkTop] <> null), assert5);
                            symbolRef := symbolStkSymbolTblRef[symbolStkTop];
                            symbolTblKind[symbolRef] := symbolStkKind[symbolStkTop];
                            symbolTblValue[symbolRef] := symbolStkValue[symbolStkTop];
                            symbolTblTypeTblLink[symbolRef] := symbolStkTypeTblLink[symbolStkTop];
                        end;

                    oSymbolTblPushScope:
                        { Push the lexic level stack with pointers to 
                          the symbol and type stack tops. }

                        if lexicLevelStackTop < lexicLevelStackSize then
                            begin
                                lexicLevelStackTop := lexicLevelStackTop + 1;
                                symbolTblDisplay[lexicLevelStackTop] := symbolTblTop;
                                typeTblDisplay[lexicLevelStackTop] := typeTblTop;
                            end
                        else
                            Error(eLexicLevelStackOvfl);

                    oSymbolTblPopScope:
                        { Pop the lexic level stack, remove local entries from the type table, 
                          remove local entries but leave parameter entries on the symbol stack. }

                        begin
                            Assert((lexicLevelStackTop >= 1), assert31);
                            i := symbolTblTop;
                            { Set the identifier table pointer to the identifier entry in the 
                              closest enclosing scope if there is one. }
                            while i > symbolTblDisplay[lexicLevelStackTop] do
                                begin
                                    link := symbolTblIdentLink[i];

                                    if link <> null then
                                        { This is not a dummy identifier generated by 
                                          the parser's syntax error recovery procedure. }
                                        begin
                                            while link > 0 do
                                                link := symbolTblIdentLink[link];
                                            identSymbolTblRef[-link] := symbolTblIdentLink[i];
                                        end;

                                    i := i - 1
                                end;

                            { Pop symbol and type table frames for scope }
                            symbolTblTop := symbolTblDisplay[lexicLevelStackTop];
                            typeTblTop := typeTblDisplay[lexicLevelStackTop];

                            lexicLevelStackTop := lexicLevelStackTop - 1;
                        end;

                    oSymbolTblPreserveParameters:
                        { Restore procedure parameter entries to the symbol table }
                        begin
                            assert (symbolTblKind [symbolTblTop] = syProcedure, assert46);
                            symbolTblTop := symbolTblTop +
                                typeTblLowerBound [symbolTblTypeTblLink[symbolTblTop]];
                        end ;

                    oSymbolTblLookupExternal:
                        { Return yes if the symbol table contains an undeclared 
                          external file name (program parameter), otherwise return no. }
                        begin
                            resultValue := no;
                            Assert((lexicLevelStackTop >= 1), assert6);
                            { Set i to point to the first symbol in the global program scope. }
                            i := symbolTblDisplay[1];
                            while i < symbolTblTop do
                                begin
                                    i := i + 1;

                                    if symbolTblKind[i] = syExternal then
                                        begin
                                            resultValue := yes;
                                            i := symbolTblTop   { exit }
                                        end
                                end
                        end;


                    { ****
                      *  *  Symbol Stack Mechanism Operations
                      **** }

                    oSymbolStkPush:
                        { Push the symbol stack, setting the kind field from the parameter. }
                        SymbolStkPush(parameterValue);

                    oSymbolStkPushIdentifier:
                        { If the last accepted identifier has a symbol table entry, 
                          push the symbol stack using the attributes of that symbol table entry,
                          otherwise push an undefined symbol. }
                        begin
                            Assert((compoundToken = sIdentifier), assert2);

                            if compoundTokenValue < 0 then
                                { This identifier was generated by the parser's 
                                  error repair mechanism. }
                                SymbolStkPush(syUndefined)
                            else if identSymbolTblRef[compoundTokenValue] > 0 then
                                { The identifier has a symbol table entry. }
                                SymbolStkPushIdentifier(identSymbolTblRef [compoundTokenValue])
                            else
                                { The identifier has no symbol table entry }
                                begin
                                    SymbolStkPush(syUndefined);
                                    symbolStkIdentTblRef[symbolStkTop] := compoundTokenValue;
                                end;
                        end;

                    oSymbolStkPushLocalIdentifier:
                        { Special case of PushIdentifier with the symbol table lookup 
                          restricted to the local scope. }
                        begin
                            Assert((compoundToken = sIdentifier), assert23);

                            if compoundTokenValue < 0 then
                                SymbolStkPush(syUndefined)
                            else if identSymbolTblRef[compoundTokenValue] > 
                                    symbolTblDisplay[lexicLevelStackTop] then
                                SymbolStkPushIdentifier(identSymbolTblRef [compoundTokenValue])
                            else
                                begin
                                    SymbolStkPush(syUndefined);
                                    symbolStkIdentTblRef[symbolStkTop] := compoundTokenValue;
                                end;
                        end;

                    oSymbolStkPushStandardVariable:
                        { If the parameter standard variable (input or output) was listed 
                          in the program parameter list and is visible in the local scope 
                          then push the symbol stack using the standard variable's 
                          symbol table attributes, otherwise push an undefined symbol. }
                        if parameterValue = stdInput then
                            begin
                                i := identSymbolTblRef [standardInputNameIndex];

                                if i > 0 then
                                    { Input (possibly user defined) is declared in some scope. }
                                    if symbolTblIdentLink[i] = -standardInputNameIndex then
                                        { Standard input is visible in the current scope. }
                                        SymbolStkPushIdentifier(i)
                                    else
                                        { Standard input is obscured by a local declaration. }
                                        SymbolStkPush(syUndefined)
                                else
                                    { Input is not a program parameter }
                                    SymbolStkPush(syUndefined)
                            end
                        else
                            begin
                                Assert((parameterValue = stdOutput), assert30);
                                i := identSymbolTblRef[standardOutputNameIndex];
                                if i > 0 then
                                    if symbolTblIdentLink[i] = -standardOutputNameIndex then
                                        SymbolStkPushIdentifier(i)
                                    else
                                        SymbolStkPush(syUndefined)
                                else
                                    SymbolStkPush(syUndefined)
                            end;

                    oSymbolStkPushFormalParameter:
                        { The top symbol is a procedure.  Push the procedure's i'th 
                          formal parameter, where i is the value of the top count stack entry. }
                        begin
                            Assert((symbolStkKind[symbolStkTop] = syProcedure), assert24);
                            SymbolStkPushIdentifier(symbolStkSymbolTblRef [symbolStkTop] + 
                                countStack[countStackTop]);
                        end;

                    oSymbolStkSetKind:
                        symbolStkKind[symbolStkTop] := parameterValue;

                    oSymbolStkEnterValue:
                        { Set the top entry's value field from the top of the value stack. }
                        symbolStkValue[symbolStkTop] := valueStack[valueStackTop];

                    oSymbolStkEnterStringValue:
                        { Set the top entry's value field from the first character 
                          of the last accepted literal string. }
                        begin
                            Assert((compoundToken = sStringLiteral), assert25);
                            symbolStkValue[symbolStkTop] := compoundTokenText[1];
                        end;

                    oSymbolStkEnterDataAddress:
                        { Set the top entry's value field to the offset of the next data object 
                          to be allocated in the data area. }
                        symbolStkValue[symbolStkTop] := dataAreaEnd;

                    oSymbolStkEnterTypeReference:
                        { Link the top entry to the top type stack's associated type table entry. }
                        begin
                            Assert((typeStkTypeTblRef[typeStkTop] <> null), assert26);
                            symbolStkTypeTblLink[symbolStkTop] := typeStkTypeTblRef[typeStkTop];
                        end;

                    oSymbolStkChooseKind:
                        resultValue := symbolStkKind[symbolStkTop];

                    oSymbolStkChooseStandardFile:
                        if symbolStkIdentTblRef[symbolStkTop] = standardInputNameIndex then
                            resultValue := stdInput
                        else if symbolStkIdentTblRef[symbolStkTop] = standardOutputNameIndex then
                            resultValue := stdOutput
                        else
                            resultValue := stdNull;

                    oSymbolStkChooseStandardRoutine:
                        { Standard routines are distinguished from user defined routines by their 
                          negative value fields. }
                        begin
                            Assert((symbolStkKind[symbolStkTop] = syProcedure) or
                                   (symbolStkKind[symbolStkTop] = syFunction), assert27);
                            if symbolStkValue[symbolStkTop] < 0 then
                                resultValue := -symbolStkValue[symbolStkTop]
                            else
                                resultValue := rtNull;
                        end;

                    oSymbolStkPop:
                        begin
                            Assert((symbolStkTop > 0), assert7);
                            symbolStkTop := symbolStkTop - 1
                        end;


                    { ****
                      *  *  Type Table Mechanism Operations
                      **** }

                    oTypeTblEnter:
                        { Create a type table entry with the attributes of the top type stack entry 
                          and link it to the top type stack entry. }

                        if typeTblTop < typeTblSize then
                            begin
                                typeTblTop := typeTblTop + 1;
                                typeTblKind[typeTblTop] := typeStkKind[typeStkTop];
                                typeTblLowerBound[typeTblTop] := typeStkLowerBound[typeStkTop];
                                typeTblUpperBound[typeTblTop] := typeStkUpperBound[typeStkTop];
                                typeTblComponentLink[typeTblTop] := 
                                    typeStkComponentLink[typeStkTop];
                                typeStkTypeTblRef[typeStkTop] := typeTblTop
                            end
                        else
                            Error(eTypeTblOvfl);

                    oTypeTblUpdate:
                        { Copy the top type stack entry attributes to the type table entry 
                          it references. }
                        begin
                            Assert((typeStkTypeTblRef[typeStkTop] <> null), assert8);
                            typeRef := typeStkTypeTblRef[typeStkTop];
                            typeTblKind[typeRef] := typeStkKind[typeStkTop];
                            typeTblLowerBound[typeRef] := typeStkLowerBound[typeStkTop];
                            typeTblUpperBound[typeRef] := typeStkUpperBound[typeStkTop];
                            typeTblComponentLink[typeRef] := typeStkComponentLink[typeStkTop];
                        end;


                    { ****
                      *  *  Type Stack Mechanism Operations
                      **** }

                    oTypeStkPush:
                        { Push and entry of the parameter kind }
                        TypeStkPush(parameterValue);

                    oTypeStkPushSymbol:
                        { If the top symbol stack entry is linked to a type table entry, 
                          push a copy of the type entry, otherwise push a null type. }
                        if symbolStkTypeTblLink[symbolStkTop] <> null then
                            TypeStkPushTypeTbl(symbolStkTypeTblLink[symbolStkTop])
                        else
                            TypeStkPush(tpNull);

                    oTypeStkPushComponent:
                        { If the top type stack entry is linked to a component type table entry 
                          push a copy of the component type entry, otherwise push a null type. }
                        if typeStkComponentLink[typeStkTop] <> null then
                            TypeStkPushTypeTbl(typeStkComponentLink[typeStkTop])
                        else
                            TypeStkPush(tpNull);

                    oTypeStkSetKind:
                        typeStkKind[typeStkTop] := parameterValue;

                    oTypeStkSetRecursionFlag:
                        { Reuse the upper bound field as the recursion flag }
                        typeStkUpperBound[typeStkTop] := parameterValue;

                    oTypeStkChooseRecursionFlag:
                        resultValue := typeStkUpperBound[typeStkTop];

                    oTypeStkLinkToStandardType:
                        { Set the top entry's component link field to point to 
                          a standard type table entry. }
                        begin
                            case parameterValue of
                                stdInteger:
                                    typeStkTypeTblRef[typeStkTop] := standardIntegerTypeRef;
                                stdChar:
                                    typeStkTypeTblRef[typeStkTop] := standardCharTypeRef;
                                stdBoolean:
                                    typeStkTypeTblRef[typeStkTop] := standardBooleanTypeRef;
                                stdText:
                                    typeStkTypeTblRef[typeStkTop] := standardTextTypeRef;
                            end
                        end;

                    oTypeStkEnterBounds:
                        { Set the upper and lower bound fields from the top and 
                          second value stack entries (respectively). }
                        begin
                            Assert((valueStackTop >= 2), assert10);
                            typeStkUpperBound[typeStkTop] := valueStack[valueStackTop];
                            typeStkLowerBound[typeStkTop] := valueStack[valueStackTop-1];
                        end;

                    oTypeStkVerifyBounds:
                        { Return yes if the upper bound field is >= the lower bound field, 
                          otherwise return no }
                        if typeStkUpperBound[typeStkTop] >= typeStkLowerBound[typeStkTop] then
                            resultValue := yes
                        else
                            resultValue := no;

                    oTypeStkEnterParameterCount:
                        { Set the top entry's parameter count field from the top count. }
                        begin
                            Assert((symbolStkKind[symbolStkTop] = syProcedure), assert28);
                            typeStkLowerBound[typeStkTop] := countStack[countStackTop];
                        end;

                    oTypeStkCompareParameterCount:
                        { Return yes if the parameter count field matches the top count, 
                          otherwise return no. }
                        begin
                            Assert((symbolStkKind[symbolStkTop] = syProcedure), assert29);
                            if typeStkLowerBound[typeStkTop] = countStack[countStackTop] then
                                resultValue := yes
                            else
                                resultValue := no;
                        end;

                    oTypeStkEnterComponentReference:
                        { Set the second entry's component link to point to the top entry's 
                          type table entry. }
                        begin
                            Assert((typeStkTop >= 2), assert11);
                            Assert((typeStkTypeTblRef[typeStkTop] <> null),assert12);
                            typeStkComponentLink[typeStkTop-1] := typeStkTypeTblRef[typeStkTop];
                        end;

                    oTypeStkChooseKind:
                        resultValue := typeStkKind[typeStkTop];

                    oTypeStkChooseTypeReference:
                        { Return yes if the top entry has an associated type table entry, 
                          otherwise return no. }
                        if typeStkTypeTblRef[typeStkTop] <> null then
                            resultValue := yes
                        else
                            resultValue := no;

                    oTypeStkCompareNames:
                        { Return yes if the top 2 entries have the same type table entry 
                          (ie were declared with the same type name), otherwise return no. }
                        begin
                            Assert((typeStkTop >= 2), assert13);
                            Assert((typeStkTypeTblRef[typeStkTop] <> null), assert14);
                            Assert((typeStkTypeTblRef[typeStkTop-1] <> null), assert15);
                            if typeStkTypeTblRef[typeStkTop] = typeStkTypeTblRef[typeStkTop-1] then
                                resultValue := yes
                            else
                                resultValue := no
                        end;

                    oTypeStkSwap:
                        { Switch the positions of the top 2 entries. }
                        begin
                            Assert((typeStkTop >= 2), assert16);

                            if typeStkTop < typeStkSize then
                                begin
                                    TypeStkCopy(typeStkTop, typeStkTop+1);
                                    TypeStkCopy(typeStkTop-1, typeStkTop);
                                    TypeStkCopy(typeStkTop+1, typeStkTop-1);
                                end
                            else
                                Error(eTypeStkOvfl)
                        end;

                    oTypeStkPop:
                        begin
                            Assert((typeStkTop > 0), assert17);
                            typeStkTop := typeStkTop -1
                        end;


                    { ****
                      *  *  Count Stack Mechanism Operations
                      **** }

                    oCountPush:
                        { Push the parameter value }
                        if countStackTop < countStackSize then
                            begin
                                countStackTop := countStackTop + 1;
                                countStack[countStackTop] := parameterValue
                            end
                        else
                            Error(eCountStackOvfl);

                    oCountPop:
                        begin
                            Assert((countStackTop >= 1), assert18);
                            countStackTop := countStackTop - 1
                        end;

                    oCountPushValue:
                        { Push the top value stack entry }
                        begin
                            Assert((valueStackTop >= 1), assert19);
                            if countStackTop < countStackSize then
                                begin
                                    countStackTop := countStackTop + 1;
                                    countStack[countStackTop] := valueStack[valueStackTop];
                                end
                            else
                                Error(eCountStackOvfl);
                        end;

                    oCountIncrement:
                        countStack[countStackTop] := countStack[countStackTop] + 1;

                    oCountDecrement:
                        countStack[countStackTop] := countStack[countStackTop] - 1;

                    oCountChoose:
                        resultValue := countStack[countStackTop];


                    { ****
                      *  *  Fix Address Stack Mechanism Operations
                      **** }

                    oFixPushTargetAddress:
                        { Push the address of the next instruction to be emitted to the code area.  
                          This address will serve as the target of a later backward branch 
                          instruction. }
                        if fixStackTop < fixStackSize then
                            begin
                                fixStackTop := fixStackTop + 1;
                                fixStack[fixStackTop] := codeAreaEnd
                            end
                        else
                            Error(eFixStackOvfl);

                    oFixPushForwardBranch:
                        { Save the address of a forward branch instruction operand which will be 
                          patched when its target becomes known. }
                        begin
                            if patchTableTop < patchTableSize then
                                begin
                                    patchTableTop := patchTableTop + 1;
                                    patchAddresses[patchTableTop] := codeAreaEnd
                                end
                            else
                                Error(ePatchTableOvfl);

                            if fixStackTop < fixStackSize then
                                begin
                                    fixStackTop := fixStackTop + 1;
                                    { Save a pointer to the patch table slot which corresponds to 
                                      this fix stack entry, so its target can be filled in when 
                                      this fix is popped. }
                                    fixStack[fixStackTop] := patchTableTop;
                                end
                            else
                                Error(eFixStackOvfl)
                        end;

                    oFixPopTargetAddress:
                        { Pop the target address of a backward branch instruction. }
                        begin
                            Assert((fixStackTop >= 1), assert32);
                            EmitOutputToken(fixStack[fixStackTop]);
                            fixStackTop := fixStackTop - 1
                        end;

                    oFixPopForwardBranch:
                        { Set the target field of a previously emitted forward branch instruction 
                          to the address of the next instruction to be emitted to the code area.  
                          The fix is made indirectly through a patch table since the code area 
                          is stored as a sequential access output file. }
                        begin
                            Assert((fixStackTop >= 1), assert33);
                            patchValues[fixStack[fixStackTop]] := codeAreaEnd;
                            fixStackTop := fixStackTop -1
                        end;

                    oFixPopAndEnterValue:
                        { Set the target field of a previously emitted forward branch instruction 
                          to the top value stack entry.  The fix is made indirectly through 
                          a patch table since the code area is stored as a sequential access file. }
                        begin
                            Assert((fixStackTop >= 1), assert48);
                            Assert((valueStackTop >= 1), assert1);
                            patchValues[fixStack[fixStackTop]] := valueStack[valueStackTop];
                            fixStackTop := fixStackTop -1
                        end;

                    oFixSwap:
                        { Switch the positions of the top 2 entries }
                        if fixStackTop < fixStackSize then
                            begin
                                Assert((fixStackTop >= 2), assert35);
                                fixStack[fixStackTop+1] := fixStack[fixStackTop];
                                fixStack[fixStackTop] := fixStack[fixStackTop-1];
                                fixStack[fixStackTop-1] := fixStack[fixStackTop+1]
                            end
                        else
                            Error(eFixStackOvfl);


                    { ****
                      *  *  Value Stack Mechanism Operations
                      **** }

                    oValuePush:
                        ValueStackPush(parameterValue);

                    oValuePushInteger:
                        { Push the value of the last integer token accepted }
                        begin
                            Assert((compoundToken = sInteger), assert36);
                            ValueStackPush(compoundTokenValue);
                        end;

                    oValuePushChar:
                        { Push the value of the last string token to be accepted }
                        begin
                            Assert((compoundToken = sStringLiteral), assert37);
                            ValueStackPush(compoundTokenText[1]);
                        end;

                    oValuePushStringLength:
                        { Push the length of the last literal string token accepted }
                        begin
                            Assert((compoundToken = sStringLiteral), assert37);
                            ValueStackPush(compoundTokenLength)
                        end;

                    oValuePushSymbol:
                        ValueStackPush(symbolStkValue[symbolStkTop]);

                    oValuePushCount:
                        begin
                            Assert((countStackTop >= 1), assert38);
                            ValueStackPush(countStack[countStackTop]);
                        end;

                    oValuePushTypeStkLowerBound:
                        ValueStackPush(typeStkLowerBound[typeStkTop]);

                    oValuePushTypeStkUpperBound:
                        ValueStackPush(typeStkUpperBound[typeStkTop]);

                    oValuePushCodeAddress:
                        { Push the offset of the next instruction to be emitted to the code area. }
                        ValueStackPush(codeAreaEnd);

                    oValueNegate:
                        begin
                            Assert((valueStackTop >= 1), assert39);
                            valueStack[valueStackTop] := -valueStack[valueStackTop];
                        end;

                    oValueChoose:
                        begin
                            Assert((valueStackTop >= 1), assert40);
                            resultValue := valueStack[valueStackTop];
                        end;

                    oValuePop:
                        begin
                            Assert((valueStackTop >= 1), assert20);
                            valueStackTop := valueStackTop - 1;
                        end;


                    { ****
                      *  *  Allocator Mechanism Operations
                      **** }

                    oAllocateAlignOnWord:
                        { Set the data area end pointer so that the next variable is emitted 
                          on a word boundary }
                        begin
                            byteOffset := dataAreaEnd mod wordSize;

                            if byteOffset <> 0 then
                                dataAreaEnd := dataAreaEnd + (wordSize - byteOffset);
                        end;

                    oAllocateVariable:
                        { Based on the structure and component entries on top of the type stack 
                          (structure on top). }
                        case typeStkKind[typeStkTop] of
                            tpInteger, tpSubrange:
                                dataAreaEnd := dataAreaEnd + wordSize;
                            tpChar, tpBoolean:
                                dataAreaEnd := dataAreaEnd + byteSize;
                            tpArray:
                                begin
                                    assert (typeStkComponentLink[typeStkTop] <> null, assert59);
                                    size := typeStkUpperBound[typeStkTop] - 
                                        typeStkLowerBound[typeStkTop] + 1;
                                    kind := typeTblKind[typeStkComponentLink[typeStkTop]];
                                    if (kind = tpInteger) or (kind = tpSubrange) then
                                        size := size * wordSize;

                                    dataAreaEnd := dataAreaEnd + size
                                end;
                        end;

                    oAllocateVarParameter, oAllocateDescriptor:
                        { A variable parameter is allocated space for an address.  
                          An array descriptor is allocated space for an array index bound value.  
                          A file descriptor is allocated space for the integer value by which
                          the file is referenced within the tCode. }
                        dataAreaEnd := dataAreaEnd + wordSize;


                    { ****
                      *  *  Case Stack Mechanism Operations
                      **** }

                    oCasePushDisplay:
                        { The case display marks the boundary between the label sets of nested 
                          cases.  A case display entry points to the last label processed in the 
                          case statement surrounding the case statement currently being processed. }
                        if caseDisplayTop < caseDisplaySize then
                            begin
                                caseDisplayTop := caseDisplayTop + 1;
                                caseDisplay[caseDisplayTop] := caseStackTop;
                            end
                        else
                            Error(eCaseDisplayOvfl);

                    oCasePopDisplay:
                        begin
                            Assert((caseDisplayTop >= 1), assert21);
                            { Restore the previous case stack top }
                            caseStackTop := caseDisplay[caseDisplayTop];
                            caseDisplayTop := caseDisplayTop - 1;
                        end;

                    oCasePushLabel:
                        { Push a label value from the value stack and set its address 
                          to the code area address of the next statement to be emitted. }
                        if caseStackTop < caseStackSize then
                            begin
                                caseStackTop := caseStackTop + 1;               
                                Assert((valueStackTop >= 1), assert41);
                                caseLabelStack[caseStackTop] := valueStack[valueStackTop];
                                caseAddressStack[caseStackTop] := codeAreaEnd;
                            end
                        else
                            Error(eCaseStackOvfl);

                    oCaseLookupLabel:
                        { Return yes if the top value is already in the label stack for the current 
                          case statement, otherwise return no. }
                        begin
                            resultValue := no;
                            { Locate the first label in this case stmt. }
                            Assert((caseDisplayTop >= 1), assert42);
                            i := caseDisplay[caseDisplayTop];
                            while i < caseStackTop do
                                begin
                                    i := i + 1;
                                    Assert((valueStackTop >= 1), assert43);

                                    if caseLabelStack[i] = valueStack[valueStackTop] then
                                        begin
                                            resultValue := yes;
                                            i := caseStackTop   { exit }
                                        end
                                end
                        end;


                    { ****
                      *  *  Emitter Mechanism Operations
                      **** }

                    oEmitNullAddress:
                        { Special undefined value allows a consistency check to be made 
                          when the address is patched. }
                        EmitOutputToken(undefined);

                    oEmitValue:
                        begin
                            Assert((valueStackTop >= 1), assert44);
                            EmitOutputToken(valueStack[valueStackTop]);
                        end;

                    oEmitDataAddress:
                        EmitOutputToken(dataAreaEnd);

                    oEmitTrapKind:
                        { Emit a trap identification value }
                        EmitOutputToken(parameterValue);

                    oEmitString:
                        { Emit the text of the last literal string accepted }
                        begin
                            Assert((compoundToken = sStringLiteral), assert45);
                            i := 1;
                            while i <= compoundTokenLength do
                                begin
                                    EmitOutputToken(compoundTokenText[i]);
                                    i := i + 1;
                                end
                        end;

                    oEmitCaseBranchTable:
                        EmitCaseBranchTable;

                end { case operation };

            until not processing;

            if not sslabort then
                Assert((eof(parseStream)), assert47);

        end { SslWalker };


    procedure Finalize;
        { Backpatch the t-code file, adding a header which includes an executable indicator flag, 
          code area size and data area size. }
        var
            codeRef:      integer;
            nextPatchRef: integer;
            codeBuffer:   integer;

        begin
            reset (temp {==, Ntemp ==} );    { Unpatched code area }
            rewrite(tCode {==, NtCode ==} ); { Final t-code file }

            { Emit a t-code file header }
            { If no errors were detected the file is marked executable }
            write(tCode, noErrors);

            { Data area size }
            write(tCode, dataAreaEnd);

            { Code area size }
            write(tCode, codeAreaEnd);

            { Patch and emit the code area }
            i := 1;
            codeRef := 0;

            while i <= patchTableTop do
                begin
                    nextPatchRef := patchAddresses[i];

                    { Copy code up to the address to be patched }
                    while codeRef < nextPatchRef do
                        begin
                            read(temp, codeBuffer);
                            write(tCode, codeBuffer);
                            codeRef := codeRef + 1
                        end;

                    read(temp, codeBuffer);
                    { Consistency check with EmitNullAddress }
                    Assert((codeBuffer = undefined), assert34);
                    write(tCode, patchValues[i]);
                    codeRef := codeRef + 1;
                    i := i + 1
                end;

            { Copy code following the final patch }
            while not eof(temp) do
                begin
                    read(temp, codeBuffer);
                    write(tCode, codeBuffer);
                end;

            { Verify that the final state of the semantic mechanism data
              structures is legal if the table walker terminated normally. }
            if not sslabort then
                { The Symbol Stack, Type Stack, Symbol and Type Display, Count Stack, Value Stack, 
                  Fix Address Stack, Case Stack and Case Display must be empty. }
                begin
                    Assert(symbolStkTop = 0, assert49);
                    Assert(typeStkTop = 0, assert50);
                    Assert(lexicLevelStackTop = 0, assert51);
                    Assert(countStackTop = 0, assert52);
                    Assert(valueStackTop = 0, assert53);
                    Assert(fixStackTop = 0, assert54);
                    Assert(caseStackTop = 0, assert55);
                    Assert(caseDisplayTop = 0, assert56);
                end;

        end;    { Finalize }

    { Main program SemanticAnalysis }
    begin
        { N.B. We assume that the invoker of the semantic pass (e.g. ptc command) has insured 
          that the input token stream coming from the parser is legal (i.e. the parser did not 
          abort translation).  If the stream is illegal it will be empty. }
        Initialize;
        SslWalker;
        Finalize;
    end { SemanticAnalysis }.
